// Generated by LiveScript 1.4.0
(function(){
  var bloop, fs, yaml, markdown, ref$, Obj, filter, keys, values, groupBy, concat, unique, map, take, sortBy, sortWith, reverse, intersection, uuid, ls, domino, RSS, eep, Section, memoize, deltosHome, BASEDIR, getFilename, evalLs, isIn, tagged, noEmpty, beginsWith, init, readConfig, writePost, editPost, normalizeDate, readEntry, readEntryFromFile, getAllEntries, localIsoTime, newNote, readStdinAsLinesThen, launchEditor, dumpTsv, htmlInit, readEntryBody, getTemplate, buildPage, entryRules, deltosLinkToHtml, getRenderedEntries, render, renderMultiple, toMarkdownLink, buildListPage, sortOrderThenDate, buildHierarchicalList, buildSite, allToJson, commands, addCommand, func, e;
  bloop = function(it){
    return console.error((new Date).toISOString() + " " + it);
  };
  bloop("requires");
  fs = require('fs');
  bloop("fs loaded");
  yaml = require('js-yaml');
  bloop("js-yaml loaded");
  markdown = require('marked');
  bloop("markdown loaded");
  ref$ = require('prelude-ls'), Obj = ref$.Obj, filter = ref$.filter, keys = ref$.keys, values = ref$.values, groupBy = ref$.groupBy, concat = ref$.concat, unique = ref$.unique, map = ref$.map, take = ref$.take, sortBy = ref$.sortBy, sortWith = ref$.sortWith, reverse = ref$.reverse, intersection = ref$.intersection;
  bloop("prelude loaded");
  uuid = require('node-uuid');
  bloop("uuid loaded");
  bloop('all-loaded');
  ls = domino = RSS = eep = Section = {};
  memoize = function(func){
    var output;
    output = null;
    return function(){
      if (output) {
        return output;
      }
      output = func();
      return output;
    };
  };
  deltosHome = (process.env.DELTOS_HOME || '~/.deltos') + '/';
  BASEDIR = deltosHome + '/by-id/';
  getFilename = function(it){
    return BASEDIR + it;
  };
  evalLs = function(it){
    return eval(ls.compile(it, {
      bare: true
    }));
  };
  isIn = curry$(function(list, item){
    return -1 < list.indexOf(item);
  });
  tagged = curry$(function(tag, entry){
    return !tag || isIn(entry.tags, tag);
  });
  noEmpty = function(it){
    return it.filter(function(it){
      return !(it === null || it === '');
    });
  };
  beginsWith = function(prefix, str){
    return str.substr(0, prefix.length) === prefix;
  };
  init = function(){
    fs.mkdirSync(deltosHome);
    return fs.mkdirSync(BASEDIR);
  };
  readConfig = memoize(function(){
    return yaml.safeLoad(fs.readFileSync(deltosHome + 'config', 'utf-8'));
  });
  writePost = function(it){
    return launchEditor(newNote(it));
  };
  editPost = function(it){
    return launchEditor(it);
  };
  normalizeDate = function(it){
    return it.date = new Date(it.date).toISOString();
  };
  readEntry = function(it){
    var ref$, header, body, metadata, series;
    ref$ = it.split("\n---\n"), header = ref$[0], body = ref$[1];
    metadata = yaml.safeLoad(header);
    normalizeDate(metadata);
    if (!metadata.title) {
      metadata.title = 'untitled';
    }
    if (!metadata.tags[0]) {
      metadata.tags = ['untagged'];
    }
    if (metadata.location) {
      metadata.location = "Click <a href=\"http://maps.google.com/?q=" + metadata.location + "\">here</a> for a map to this location.";
    }
    if (metadata.series) {
      series = readEntryFromFile(getFilename(metadata.series));
      metadata.series = "This post is part of series on <a href=\"/by-id/" + series.id + ".html\">" + series.title + "</a>.";
    }
    if (metadata.parent) {
      if (!metadata.parents) {
        metadata.parents = [];
      }
      metadata.parents.push(metadata.parent);
      delete metadata.parent;
    }
    metadata.rawBody = body;
    return metadata;
  };
  readEntryFromFile = function(it){
    var entry;
    entry = fs.readFileSync(it, 'utf-8');
    return readEntry(entry);
  };
  getAllEntries = memoize(function(){
    var entries, i$, ref$, len$, ff, entry, j$, len1$, parent;
    console.error("getting all entries");
    entries = {};
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      entry = readEntryFromFile(BASEDIR + ff);
      entries[entry.id] = entry;
    }
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      if (entry.parents) {
        for (j$ = 0, len1$ = (ref$ = entry.parents).length; j$ < len1$; ++j$) {
          parent = ref$[j$];
          if (!entries[parent].children) {
            entries[parent].children = [];
          }
          entries[parent].children.push(entry.id);
        }
      }
    }
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    values(entries)));
  });
  localIsoTime = function(){
    var offset, offsetMs, localTime, offsetHours, offsetDoubleOhHours, offsetPrefix, offsetString;
    offset = new Date().getTimezoneOffset();
    offsetMs = offset * 60000;
    localTime = new Date(Date.now() - offsetMs).toISOString().slice(0, -1);
    offsetHours = offset / 60;
    offsetDoubleOhHours = ~~offsetHours * 100;
    if (offsetHours % 1 !== 0) {
      offsetDoubleOhHours += 50;
    }
    offsetPrefix = '-';
    if (offsetDoubleOhHours < 0) {
      offsetPrefix = '+';
      offsetDoubleOhHours *= -1;
    }
    offsetString = '000000' + offsetDoubleOhHours;
    offsetString = offsetString.slice(offsetString.length - 4);
    return localTime + offsetPrefix + offsetString;
  };
  newNote = function(title){
    var id, fname, now, buf;
    title == null && (title = "");
    for (;;) {
      id = uuid.v4();
      fname = getFilename('id');
      if (!fs.existsSync(fname)) {
        break;
      }
    }
    now = localIsoTime();
    buf = ["id: " + id, "date: " + now, "title: " + title, "tags: []", "---\n"].join("\n");
    fs.writeFileSync(fname, buf);
    return fname;
  };
  readStdinAsLinesThen = function(func){
    var buf;
    buf = '';
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(it){
      return buf += it;
    });
    return process.stdin.on('end', function(){
      return func(noEmpty(
      buf.split("\n")));
    });
  };
  launchEditor = function(file, after){
    var spawn, cp;
    spawn = require('child_process').spawn;
    cp = spawn(process.env.EDITOR, [file], {
      stdio: 'inherit'
    });
    return typeof after == 'function' ? after() : void 8;
  };
  dumpTsv = function(){
    var entries, out, i$, len$, entry;
    bloop('starting-tsv');
    entries = getAllEntries();
    bloop('got-entries');
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      out.push([entry.id, entry.title, entry.tags.join(',')].join('\t'));
    }
    bloop('serialized');
    return out.join("\n");
  };
  htmlInit = function(){
    eep = require('./equaeverpoise');
    Section = eep.Section;
    domino = require('domino');
    RSS = require('rss');
    return ls = require('livescript');
  };
  readEntryBody = function(it){
    var expanded, i$, ref$, len$, line, words, command, imgTag, caption, vidTag;
    expanded = '';
    for (i$ = 0, len$ = (ref$ = it.split("\n")).length; i$ < len$; ++i$) {
      line = ref$[i$];
      if (beginsWith(']', line)) {
        line = evalLs(line.substr(1));
      } else if (beginsWith('!', line)) {
        line = line.slice(1);
        words = line.split(' ');
        command = words.shift();
        switch (command) {
        case 'img':
          imgTag = "<img src=\"" + words.shift() + "\"/>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + imgTag + caption + "</div>";
          break;
        case 'video':
          vidTag = "<video preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\" style=\"width: 100%; height: auto;\" controls> <source src=\"" + words.shift() + "\" type='video/webm; codecs=\"vp8, vorbis\"'></source> </video>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + vidTag + caption + "</div>";
          break;
        case 'archive':
          line = buildListPage().join("\n");
          break;
        case '.rule':
          line = '<p class="rule">' + markdown(words.join(' ')).substr(3);
          break;
        default:
          'noop';
        }
      }
      expanded += line + "\n";
    }
    expanded = deltosLinkToHtml(expanded);
    return markdown(expanded);
  };
  getTemplate = memoize(function(){
    return function(it){
      return domino.createWindow(it).document;
    }(
    fs.readFileSync(deltosHome + 'single.html', 'utf-8'));
  });
  buildPage = function(eep, content){
    var template;
    if (content.rawBody) {
      content.body = readEntryBody(content.rawBody);
      delete content.rawBody;
    }
    template = getTemplate();
    eep.push(template.body, content, template.body);
    if (content.title) {
      template.title = content.title;
    }
    return template.outerHTML;
  };
  entryRules = function(){
    var page, linkPusher;
    page = new Section();
    page.rule('h1', 'title');
    page.rule('h4', 'subtitle');
    page.rule('.location', 'location');
    page.rule('.series', 'series');
    page.rule('.date', 'date');
    page.rule('.content', 'body');
    linkPusher = function(el, link){
      return el.href = link;
    };
    page.rule('.article-link', 'link', {
      push: linkPusher
    });
    return page;
  };
  deltosLinkToHtml = function(it){
    var linkRegex;
    linkRegex = /\.\(([^\/]*)\/\/([^\)]*)\)/g;
    return it.replace(linkRegex, function(matched, label, dest){
      return "<a href=\"/by-id/" + dest + ".html\">" + label + "</a>";
    });
  };
  getRenderedEntries = function(){
    var entries, i$, len$, entry;
    entries = getAllEntries();
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.body = readEntryBody(entry.rawBody);
      delete entry.rawBody;
    }
    return entries;
  };
  render = function(it){
    var entry;
    entry = readEntryFromFile(getFilename(it));
    entry.link = '/by-id/' + entry.id + '.html';
    return buildPage(entryRules(), entry);
  };
  renderMultiple = function(ids){
    var entries, page;
    entries = ids.map(function(it){
      return readEntryFromFile(getFilename(it));
    });
    entries.map(function(it){
      it.link = '/by-id/' + it.id + '.html';
      return it;
    });
    entries.map(function(it){
      var ref$;
      it.body = readEntryBody(it.rawBody);
      return ref$ = it.rawBody, delete it.rawBody, ref$;
    });
    page = new Section();
    page.listRule('#column', 'entries', entryRules());
    return buildPage(page, {
      entries: entries
    });
  };
  toMarkdownLink = function(it){
    var tags;
    tags = it.tags.filter(function(it){
      return it !== 'published';
    }).join(", ");
    return "- [" + it.title + "](/by-id/" + it.id + ".html) <span class=\"tags\">" + tags + "</span>";
  };
  buildListPage = function(){
    var tags, entries, config, i$, ref$, len$, tag;
    tags = ['published'].concat(process.argv.slice(3));
    entries = getAllEntries();
    config = readConfig();
    for (i$ = 0, len$ = (ref$ = config.site["exclude-tags"]).length; i$ < len$; ++i$) {
      tag = ref$[i$];
      entries = entries.filter(fn$);
    }
    for (i$ = 0, len$ = tags.length; i$ < len$; ++i$) {
      tag = tags[i$];
      entries = entries.filter(fn1$);
    }
    return map(toMarkdownLink)(
    reverse(
    sortBy(function(it){
      return it.date;
    }, entries)));
    function fn$(it){
      return !tagged(tag, it);
    }
    function fn1$(it){
      return tagged(tag, it);
    }
  };
  sortOrderThenDate = function(a, b){
    if ((a != null && a.order) && (b != null && b.order)) {
      if (a.order < b.order) {
        return 1;
      } else {
        return -1;
      }
    }
    if (a.date > b.date) {
      return -1;
    } else {
      return 1;
    }
  };
  buildHierarchicalList = function(entries, depth, parent){
    var children, out, spacer, i$, len$, child;
    parent == null && (parent = null);
    if (depth === 0) {
      return '';
    }
    if (parent) {
      children = entries.filter(function(it){
        return it.parents && isIn(it.parents, parent);
      });
    } else {
      children = entries.filter(function(it){
        return !it.parents;
      });
    }
    children = sortWith(sortOrderThenDate, children);
    out = '';
    spacer = parent ? '  ' : '';
    for (i$ = 0, len$ = children.length; i$ < len$; ++i$) {
      child = children[i$];
      out += spacer + toMarkdownLink(child) + "\n";
      if (depth > 0) {
        out += buildHierarchicalList(entries, depth - 1, child.id).split("\n").map(fn$).join('\n');
      }
    }
    return out;
    function fn$(it){
      return spacer + it;
    }
  };
  buildSite = function(){
    var config, published, siteRoot, entries, i$, len$, entry, page, fname, rss;
    bloop("html-init");
    htmlInit();
    bloop("html-init done");
    config = readConfig();
    bloop("config read");
    published = config.site.tag;
    siteRoot = deltosHome + 'site/';
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    filter(tagged(published))(
    getRenderedEntries())));
    bloop("got rendered entries");
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      page = render(entry.id);
      fname = siteRoot + "/by-id/" + entry.id + ".html";
      fs.writeFileSync(fname, page);
    }
    bloop("wrote each post");
    rss = new RSS({
      title: config.site.title,
      description: config.site.description,
      generator: 'deltos',
      site_url: config.site.url,
      feed_url: config.site.url + "/index.rss",
      pubDate: new Date()
    });
    bloop("made rss");
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.description = entry.body;
      entry.categories = entry.tags;
      entry.url = entry.link;
      entry.guid = entry.link;
      rss.item(entry);
    }
    bloop("added rss items");
    fs.writeFileSync(siteRoot + "index.rss", rss.xml());
    bloop("wrote rss");
    return process.exit(0);
  };
  allToJson = function(){
    var entries, i$, len$, entry, results$ = [];
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    getAllEntries()));
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.tags = entry.tags.map(String);
      results$.push(console.log(JSON.stringify(entry)));
    }
    return results$;
  };
  commands = [];
  addCommand = function(name, desc, func){
    func.command = name;
    func.desc = desc;
    name = name.split(" ")[0];
    return commands[name] = func;
  };
  addCommand("init", "Set up DELTOS_HOME", init);
  addCommand("post [title...]", "Start a new post in $EDITOR", function(){
    return writePost(process.argv.slice(2).join(' '));
  });
  addCommand("edit [id]", "Edit an existing post", function(){
    return editPost(getFilename(process.argv[3]));
  });
  addCommand("render [id]", "Render [id] as HTML", function(){
    return console.log(render(process.argv[3]));
  });
  addCommand('build-site', "Build static HTML", buildSite);
  addCommand('json', "Dump all entries to JSON", allToJson);
  addCommand('tsv', "Dump basic TSV", function(){
    return console.log(dumpTsv());
  });
  addCommand('list-test', "Show hierarchical list", function(){
    return console.log(buildHierarchicalList(getAllEntries(), 3));
  });
  addCommand('help', "Show this help", function(){
    var name, ref$, func;
    console.log("usage: deltos <command> [options...]\n");
    for (name in ref$ = commands) {
      func = ref$[name];
      console.log("\t" + func.command + "\t\t" + func.desc);
    }
    return process.exit(1);
  });
  try {
    func = commands[process.argv[2]];
  } catch (e$) {
    e = e$;
    func = commands.help();
  }
  func();
  bloop('done');
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
