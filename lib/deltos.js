// Generated by LiveScript 1.4.0
(function(){
  var fs, Yaml, yaml, markdown, ref$, Obj, filter, keys, values, groupBy, concat, unique, map, take, sortBy, sortWith, reverse, intersection, uuid, memoize, isIn, noEmpty, tagged, normalizeDate, localIsoTime, readStdinAsLinesThen, launchEditor, ls, domino, RSS, eep, Section, evalLs, deltosHome, BASEDIR, getFilename, init, newNote, writeDaily, writePost, editPost, render, buildPrivateReference, buildSite, allToJson, dumpTodos, dumpTsv, readConfig, readEntry, readEntryFromFile, getChildEntries, getAllEntries, getNewId, newDaily, htmlInit, beginsWith, readEntryBody, getTemplate, searchableText, buildPage, entryRules, deltosLinkToHtml, getRenderedEntries, toMarkdownLink, buildListPage, sortOrderThenDate, buildHierarchicalList, getEntriesToBuild, buildSiteHtml, buildRss, commands, addCommand, func, e;
  fs = require('fs');
  Yaml = require('js-yaml');
  yaml = function(it){
    return Yaml.safeLoad(it, {
      schema: Yaml.FAILSAFE_SCHEMA
    });
  };
  markdown = require('marked');
  ref$ = require('prelude-ls'), Obj = ref$.Obj, filter = ref$.filter, keys = ref$.keys, values = ref$.values, groupBy = ref$.groupBy, concat = ref$.concat, unique = ref$.unique, map = ref$.map, take = ref$.take, sortBy = ref$.sortBy, sortWith = ref$.sortWith, reverse = ref$.reverse, intersection = ref$.intersection;
  uuid = require('node-uuid');
  ref$ = require('./util'), memoize = ref$.memoize, isIn = ref$.isIn, noEmpty = ref$.noEmpty, tagged = ref$.tagged, normalizeDate = ref$.normalizeDate, localIsoTime = ref$.localIsoTime, readStdinAsLinesThen = ref$.readStdinAsLinesThen, launchEditor = ref$.launchEditor;
  ls = domino = RSS = eep = Section = {};
  evalLs = function(it){
    return eval(ls.compile(it, {
      bare: true
    }));
  };
  deltosHome = (process.env.DELTOS_HOME || '~/.deltos') + '/';
  BASEDIR = deltosHome + '/by-id/';
  getFilename = function(it){
    return BASEDIR + it;
  };
  init = function(){
    var mkdirp;
    mkdirp = require('mkdirp');
    mkdirp.sync(BASEDIR);
    return mkdirp.sync(deltosHome + 'site');
  };
  newNote = function(title, tags){
    var id, fname, now, buf;
    title == null && (title = "");
    tags == null && (tags = []);
    id = getNewId();
    fname = getFilename(id);
    now = localIsoTime();
    buf = ["id: " + id, "date: " + now, "title: " + title, "tags: [" + tags.join(", ") + "]", "---\n"].join("\n");
    fs.writeFileSync(fname, buf);
    return fname;
  };
  writeDaily = function(){
    return launchEditor(newDaily());
  };
  writePost = function(it){
    return launchEditor(newNote(it));
  };
  editPost = function(it){
    return launchEditor(it);
  };
  render = function(it){
    it.link = '/by-id/' + it.id + '.html';
    return buildPage(entryRules(), it);
  };
  buildPrivateReference = function(){
    return buildSite(true);
  };
  buildSite = function(priv){
    var config, published, siteRoot, entries;
    priv == null && (priv = false);
    htmlInit();
    config = readConfig();
    published = config.site.tag;
    siteRoot = deltosHome + 'site/';
    if (priv) {
      siteRoot = deltosHome + 'private/';
    }
    entries = getEntriesToBuild(published, priv);
    buildSiteHtml(siteRoot, entries);
    return buildRss(siteRoot, config, entries);
  };
  allToJson = function(){
    var entries, i$, len$, entry, results$ = [];
    htmlInit();
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    getRenderedEntries()));
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.tags = entry.tags.map(String);
      entry.body = searchableText(entry.body);
      results$.push(console.log(JSON.stringify(entry)));
    }
    return results$;
  };
  dumpTodos = function(){
    var entries;
    entries = sortBy(function(it){
      return it.todo;
    })(
    filter(function(it){
      return it.todo && !it.done;
    })(
    getAllEntries()));
    return entries.map(function(it){
      return "- .(" + it.title + "//" + it.id + ") " + it.todo;
    }).join("\n");
  };
  dumpTsv = function(){
    var entries, out, i$, len$, entry;
    entries = getAllEntries();
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      out.push([entry.id, entry.title, entry.tags.join(',')].join('\t'));
    }
    return out.join("\n");
  };
  readConfig = memoize(function(){
    var e;
    try {
      return yaml(fs.readFileSync(deltosHome + 'config', 'utf-8'));
    } catch (e$) {
      e = e$;
      console.error("Error reading config:" + e.message);
      return process.exit(1);
    }
  });
  readEntry = function(it){
    var ref$, header, body, metadata, e, collection, colls, i$, len$, coll;
    ref$ = it.split("\n---\n"), header = ref$[0], body = ref$[1];
    try {
      metadata = yaml(header);
    } catch (e$) {
      e = e$;
      console.error("Error parsing YAML header:\n" + header);
      console.error("Error message:" + e.message);
      process.exit(1);
    }
    normalizeDate(metadata);
    if (!metadata.title) {
      metadata.title = 'untitled';
    }
    if (!metadata.tags[0]) {
      metadata.tags = ['untagged'];
    }
    if (metadata.location) {
      metadata.location = "Click <a href=\"http://maps.google.com/?q=" + metadata.location + "\">here</a> for a map to this location.";
    }
    if (metadata.parent) {
      if (!metadata.parents) {
        metadata.parents = [];
      }
      metadata.parents.push(metadata.parent);
      delete metadata.parent;
    }
    if (metadata.parents) {
      if (metadata.parents.length === 1) {
        collection = readEntryFromFile(getFilename(metadata.parents[0]));
        metadata.collections = "This post is part of a collection on <a href=\"/by-id/" + collection.id + ".html\">" + collection.title + "</a>.";
      } else {
        metadata.collections = "This post is part of collections on ";
        colls = [];
        for (i$ = 0, len$ = (ref$ = metadata.parents).length; i$ < len$; ++i$) {
          coll = ref$[i$];
          collection = readEntryFromFile(getFilename(coll));
          colls.push("<a href=\"/by-id/" + collection.id + ".html\">" + collection.title + "</a>");
        }
        colls[colls.length - 1] = "and " + colls[colls.length - 1] + ".";
        metadata.collections += colls.join(", ");
      }
    }
    metadata.rawBody = body;
    return metadata;
  };
  readEntryFromFile = function(it){
    var entry;
    entry = fs.readFileSync(it, 'utf-8');
    return readEntry(entry);
  };
  getChildEntries = function(parent){
    var out;
    out = getAllEntries().filter(function(it){
      return -1 !== parent.children.indexOf(it.id);
    });
    return out;
  };
  getAllEntries = memoize(function(){
    var entries, i$, ref$, len$, ff, entry, key, parent;
    entries = {};
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      entry = readEntryFromFile(BASEDIR + ff);
      entries[entry.id] = entry;
    }
    for (key in entries) {
      entry = entries[key];
      if (entry.parent) {
        entry.parents = [entry.parent];
      }
      if (entry.parents) {
        for (i$ = 0, len$ = (ref$ = entry.parents).length; i$ < len$; ++i$) {
          parent = ref$[i$];
          if (!entries[parent].children) {
            entries[parent].children = [];
          }
          entries[parent].children.push(entry.id);
        }
      }
    }
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    values(entries)));
  });
  getNewId = function(){
    var id, ref$, fname;
    for (;;) {
      id = uuid.v4();
      id = [(ref$ = id.split('').reverse())[0], ref$[1], ref$[2], ref$[3], ref$[4], ref$[5], ref$[6], ref$[7]].join('');
      fname = getFilename(id);
      if (!fs.existsSync(fname)) {
        return id;
      }
    }
  };
  newDaily = function(){
    var today, entries, fname;
    today = localIsoTime().substr(0, 10);
    entries = getAllEntries().filter(function(it){
      return tagged('daily', it) && today === it.date.substr(0, 10);
    });
    if (entries.length > 0) {
      return getFilename(entries[0].id);
    }
    fname = newNote("Daily Notes - " + today, ['daily']);
    fs.appendFileSync(fname, "deltos todos\n");
    fs.appendFileSync(fname, dumpTodos());
    fs.appendFileSync(fname, "\n\n");
    return fname;
  };
  htmlInit = function(){
    eep = require('./equaeverpoise');
    Section = eep.Section;
    domino = require('domino');
    RSS = require('rss');
    return ls = require('livescript');
  };
  beginsWith = function(prefix, str){
    return str.substr(0, prefix.length) === prefix;
  };
  readEntryBody = function(it){
    var raw, expanded, i$, ref$, len$, line, words, command, imgTag, caption, vidTag;
    raw = it.rawBody;
    expanded = '';
    if (!raw) {
      return '';
    }
    for (i$ = 0, len$ = (ref$ = raw.split("\n")).length; i$ < len$; ++i$) {
      line = ref$[i$];
      if (beginsWith(']', line)) {
        line = evalLs(line.substr(1));
      } else if (beginsWith('!', line)) {
        line = line.slice(1);
        words = line.split(' ');
        command = words.shift();
        switch (command) {
        case 'img':
          imgTag = "<img src=\"" + words.shift() + "\"/>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + imgTag + caption + "</div>";
          break;
        case 'video':
          vidTag = "<video preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\" style=\"width: 100%; height: auto;\" controls> <source src=\"" + words.shift() + "\" type='video/webm; codecs=\"vp8, vorbis\"'></source> </video>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + vidTag + caption + "</div>";
          break;
        case 'archive':
          line = buildListPage().join("\n");
          break;
        case 'children':
          line = buildListPage(getChildEntries(it)).join("\n");
          break;
        case '.rule':
          line = '<p class="rule">' + markdown(words.join(' ')).substr(3);
          break;
        default:
          'noop';
        }
      }
      expanded += line + "\n";
    }
    expanded = deltosLinkToHtml(expanded);
    return markdown(expanded);
  };
  getTemplate = memoize(function(){
    return function(it){
      return domino.createWindow(it).document;
    }(
    fs.readFileSync(deltosHome + 'single.html', 'utf-8'));
  });
  searchableText = function(it){
    return domino.createWindow(it).document.body.textContent.toLowerCase();
  };
  buildPage = function(eep, content){
    var template;
    if (content.rawBody) {
      content.body = readEntryBody(content);
      delete content.rawBody;
    }
    template = getTemplate();
    eep.push(template.body, content, template.body);
    if (content.title) {
      template.title = content.title;
    }
    return template.outerHTML;
  };
  entryRules = function(){
    var page, linkPusher;
    page = new Section();
    page.rule('h1', 'title');
    page.rule('h4', 'subtitle');
    page.rule('.location', 'location');
    page.rule('.collections', 'collections');
    page.rule('.date', 'date');
    page.rule('.content', 'body');
    linkPusher = function(el, link){
      return el.href = link;
    };
    page.rule('.article-link', 'link', {
      push: linkPusher
    });
    return page;
  };
  deltosLinkToHtml = function(it){
    var linkRegex;
    linkRegex = /\.\(([^\/]*)\/\/([^\)]*)\)/g;
    return it.replace(linkRegex, function(matched, label, dest){
      return "<a href=\"/by-id/" + dest + ".html\">" + label + "</a>";
    });
  };
  getRenderedEntries = function(){
    var entries, i$, len$, entry;
    entries = getAllEntries();
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.body = readEntryBody(entry);
      delete entry.rawBody;
    }
    return entries;
  };
  toMarkdownLink = function(it){
    var tags;
    tags = it.tags.filter(function(it){
      return it !== 'published';
    }).join(", ");
    return "- [" + it.title + "](/by-id/" + it.id + ".html) <span class=\"tags\">" + tags + "</span>";
  };
  buildListPage = function(entries){
    var config, i$, ref$, len$, tag;
    if (!entries) {
      entries = getAllEntries();
    }
    config = readConfig();
    for (i$ = 0, len$ = (ref$ = config.site["exclude-tags"]).length; i$ < len$; ++i$) {
      tag = ref$[i$];
      entries = entries.filter(fn$);
    }
    entries = entries.filter(function(it){
      return tagged('published', it);
    });
    return map(toMarkdownLink)(
    reverse(
    sortBy(function(it){
      return it.date;
    }, entries)));
    function fn$(it){
      return !tagged(tag, it);
    }
  };
  sortOrderThenDate = function(a, b){
    if ((a != null && a.order) && (b != null && b.order)) {
      if (a.order < b.order) {
        return 1;
      } else {
        return -1;
      }
    }
    if (a.date > b.date) {
      return -1;
    } else {
      return 1;
    }
  };
  buildHierarchicalList = function(entries, depth, parent){
    var children, out, spacer, i$, len$, child;
    parent == null && (parent = null);
    if (depth === 0) {
      return '';
    }
    if (parent) {
      children = entries.filter(function(it){
        return it.parents && isIn(it.parents, parent);
      });
    } else {
      children = entries.filter(function(it){
        return !it.parents;
      });
    }
    children = sortWith(sortOrderThenDate, children);
    out = '';
    spacer = parent ? '  ' : '';
    for (i$ = 0, len$ = children.length; i$ < len$; ++i$) {
      child = children[i$];
      out += spacer + toMarkdownLink(child) + "\n";
      if (depth > 0) {
        out += buildHierarchicalList(entries, depth - 1, child.id).split("\n").map(fn$).join('\n');
      }
    }
    return out;
    function fn$(it){
      return spacer + it;
    }
  };
  getEntriesToBuild = function(published, priv){
    var entries;
    entries = getRenderedEntries();
    if (!priv) {
      entries = filter(tagged(published))(
      entries);
    }
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    entries));
  };
  buildSiteHtml = function(root, entries){
    var i$, len$, entry, page, fname, results$ = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      page = render(entry);
      fname = root + "/by-id/" + entry.id + ".html";
      results$.push(fs.writeFileSync(fname, page));
    }
    return results$;
  };
  buildRss = function(root, config, entries){
    var rss, i$, ref$, len$, tag, entry;
    rss = new RSS({
      title: config.site.title,
      description: config.site.description,
      generator: 'deltos',
      site_url: config.site.url,
      feed_url: config.site.url + "/index.rss",
      pubDate: new Date()
    });
    for (i$ = 0, len$ = (ref$ = config.site["exclude-tags"]).length; i$ < len$; ++i$) {
      tag = ref$[i$];
      entries = entries.filter(fn$);
    }
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.description = entry.body;
      entry.categories = entry.tags;
      entry.url = entry.link;
      entry.guid = entry.link;
      rss.item(entry);
    }
    return fs.writeFileSync(root + "index.rss", rss.xml());
    function fn$(it){
      return !tagged(tag, it);
    }
  };
  commands = [];
  addCommand = function(name, desc, func){
    func.command = name;
    func.desc = desc;
    name = name.split(" ")[0];
    return commands[name] = func;
  };
  addCommand("init", "Set up DELTOS_HOME", init);
  addCommand("new [title...]", "Create a note and print the filename", function(){
    return console.log(newNote(process.argv.slice(3).join(' ')));
  });
  addCommand("daily", "Create a daily note and open in $EDITOR", function(){
    return writeDaily();
  });
  addCommand("post [title...]", "Start a new post in $EDITOR", function(){
    return writePost(process.argv.slice(3).join(' '));
  });
  addCommand("edit [id]", "Edit an existing post", function(){
    return editPost(getFilename(process.argv[3]));
  });
  addCommand("render [id]", "Render [id] as HTML", function(){
    return console.log(render(process.argv[3]));
  });
  addCommand('build-site', "Build static HTML", function(){
    buildSite();
    return buildPrivateReference();
  });
  addCommand('json', "Dump all entries to JSON", allToJson);
  addCommand('todos', "Dump todo list", function(){
    return console.log(dumpTodos());
  });
  addCommand('tsv', "Dump basic TSV", function(){
    return console.log(dumpTsv());
  });
  addCommand('version', "Show version number", function(){
    var pkg;
    pkg = require('../package.json');
    return console.log(pkg.version);
  });
  addCommand('help', "Show this help", function(){
    var name, ref$, func;
    console.log("usage: deltos <command> [options...]\n");
    for (name in ref$ = commands) {
      func = ref$[name];
      console.log("\t" + func.command + "\t\t" + func.desc);
    }
    return process.exit(1);
  });
  try {
    func = commands[process.argv[2]];
  } catch (e$) {
    e = e$;
    func = commands.help();
  }
  if (!func) {
    func = commands.help;
  }
  func();
}).call(this);
