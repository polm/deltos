// Generated by LiveScript 1.2.0
(function(){
  var ls, fs, yaml, markdown, ref$, Obj, filter, keys, values, groupBy, concat, unique, map, take, sortBy, reverse, uuid, createMenu, eep, Section, jsdom, childProcess, spawn, deltosHome, evalLs, isIn, tagged, noEmpty, beginsWith, getFilename, deltosLinkToHtml, init, readEntryBody, readEntry, check, indent, quoteIndent, show, quote, code, BASEDIR, readEntryFromFile, getAllEntries, byTitle, hasTag, recentFirst, newNote, printNewNoteName, updateSymlinkDir, updateSymlinks, selectMenu, searchTitle, searchTag, searchTagInteractive, searchTagPipe, buildPage, entryRules, render, readStdinAsLinesThen, renderLog, entryToMarkdownLink, entryToLink, printResult, asMarkdownLinks, recent, launchEditor, writePost;
  ls = require('LiveScript');
  fs = require('fs');
  yaml = require('js-yaml');
  markdown = require('marked');
  ref$ = require('prelude-ls'), Obj = ref$.Obj, filter = ref$.filter, keys = ref$.keys, values = ref$.values, groupBy = ref$.groupBy, concat = ref$.concat, unique = ref$.unique, map = ref$.map, take = ref$.take, sortBy = ref$.sortBy, reverse = ref$.reverse;
  uuid = require('node-uuid');
  createMenu = require('terminal-menu');
  eep = require('./equaeverpoise');
  Section = eep.Section;
  jsdom = require('jsdom').jsdom;
  childProcess = require('child_process');
  spawn = childProcess.spawn;
  deltosHome = (process.env.DELTOS_HOME || '~/.deltos') + '/';
  evalLs = function(it){
    return eval(ls.compile(it, {
      bare: true
    }));
  };
  isIn = curry$(function(list, item){
    return -1 < list.indexOf(item);
  });
  tagged = curry$(function(tag, entry){
    return !tag || isIn(entry.tags, tag);
  });
  noEmpty = function(it){
    return it.filter(function(it){
      return !(it === null || it === '');
    });
  };
  beginsWith = function(prefix, str){
    return str.substr(0, prefix.length) === prefix;
  };
  getFilename = function(it){
    return deltosHome + '/by-id/' + it;
  };
  deltosLinkToHtml = function(it){
    var linkRegex;
    linkRegex = /\.\(([^\/]*)\/\/([^\)]*)\)/g;
    return it.replace(linkRegex, function(matched, label, dest){
      return "<a href=\"/by-id/" + dest + ".html\">" + label + "</a>";
    });
  };
  init = function(){
    fs.mkdirSync(deltosHome);
    fs.mkdirSync(deltosHome + '/by-id');
    fs.mkdirSync(deltosHome + '/by-tag');
    fs.mkdirSync(deltosHome + '/by-title');
    return fs.mkdirSync(deltosHome + '/by-date');
  };
  readEntryBody = function(it){
    var expanded, i$, ref$, len$, line, words, command, imgTag, caption;
    expanded = '';
    for (i$ = 0, len$ = (ref$ = it.split("\n")).length; i$ < len$; ++i$) {
      line = ref$[i$];
      if (beginsWith(']', line)) {
        line = evalLs(line.substr(1));
      } else if (beginsWith('!', line)) {
        line = line.slice(1);
        words = line.split(' ');
        command = words.shift();
        switch (command) {
        case 'img':
          imgTag = "<p class=\"img\"><img src=\"" + words.shift() + "\"/></p>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = imgTag + caption;
          break;
        default:
          'noop';
        }
      }
      expanded += line + "\n";
    }
    expanded = deltosLinkToHtml(expanded);
    return markdown(expanded);
  };
  readEntry = function(it){
    var ref$, header, body, metadata;
    ref$ = it.split("\n---\n"), header = ref$[0], body = ref$[1];
    metadata = yaml.safeLoad(header);
    if (metadata.date.toISOString) {
      metadata.date = metadata.date.toISOString();
    }
    if (!metadata.title) {
      metadata.title = 'untitled';
    }
    if (!metadata.tags[0]) {
      metadata.tags = ['untagged'];
    }
    if (metadata.tags[0].indexOf(' ') > -1) {
      metadata.tags = metadata.tags[0].split(' ');
    }
    metadata.body = readEntryBody(body);
    return metadata;
  };
  check = function(it){
    console.log(it);
    return it;
  };
  indent = function(it){
    return "    " + it.split("\n").join("\n    ");
  };
  quoteIndent = function(it){
    return "    > " + it.split("\n").join("\n    > ");
  };
  show = function(it){
    return map(function(it){
      return it.body;
    }, it).join("\n");
  };
  quote = function(it){
    return quoteIndent(
    show(it));
  };
  code = function(it){
    return indent(
    show(it));
  };
  BASEDIR = deltosHome + '/by-id/';
  readEntryFromFile = function(it){
    var entry;
    entry = fs.readFileSync(it, 'utf-8');
    return readEntry(entry);
  };
  getAllEntries = function(){
    var i$, ref$, len$, ff, results$ = [];
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      results$.push(readEntryFromFile(BASEDIR + ff));
    }
    return results$;
  };
  byTitle = curry$(function(title, entries){
    return entries.filter(function(it){
      return it.title === title;
    });
  });
  hasTag = curry$(function(tag, entries){
    return entries.filter(function(it){
      return it.tags.indexOf(tag) > -1;
    });
  });
  recentFirst = function(entries){
    return sortBy(function(it){
      return it.date;
    }, entries);
  };
  newNote = function(){
    var id, fname, now, buf;
    for (;;) {
      id = uuid.v4();
      fname = [deltosHome, '/by-id/', id].join('');
      if (!fs.existsSync(fname)) {
        break;
      }
    }
    now = new Date().toISOString();
    buf = ["id: " + id, "date: " + now, "title: " + process.argv.slice(3).join(' '), "tags: []", "---\n"].join("\n");
    fs.writeFileSync(fname, buf);
    return fname;
  };
  printNewNoteName = function(){
    return console.log(newNote());
  };
  updateSymlinkDir = function(path, matches){
    var contents, i$, len$, ff, duds, j$, len1$, dud, ref$, key, lresult$, e, dirContents, ref1$, mat, results$ = [];
    path = deltosHome + '/' + path;
    contents = fs.readdirSync(path);
    for (i$ = 0, len$ = contents.length; i$ < len$; ++i$) {
      ff = contents[i$];
      if (0 > keys(matches).indexOf(ff)) {
        duds = fs.readdirSync(path + '/' + ff);
        for (j$ = 0, len1$ = duds.length; j$ < len1$; ++j$) {
          dud = duds[j$];
          fs.unlinkSync(path + '/' + ff + '/' + dud);
        }
        fs.rmdirSync(path + '/' + ff);
      }
    }
    for (i$ = 0, len$ = (ref$ = keys(matches)).length; i$ < len$; ++i$) {
      key = ref$[i$];
      lresult$ = [];
      if (0 > contents.indexOf(key)) {
        try {
          fs.mkdirSync(path + '/' + key);
        } catch (e$) {
          e = e$;
          'nothing';
        }
      }
      dirContents = fs.readdirSync(path + '/' + key);
      for (j$ = 0, len1$ = dirContents.length; j$ < len1$; ++j$) {
        ff = dirContents[j$];
        if (0 > matches[key].indexOf(ff)) {
          fs.unlinkSync(path + '/' + key + '/' + ff);
        }
      }
      for (j$ = 0, len1$ = (ref1$ = matches[key]).length; j$ < len1$; ++j$) {
        mat = ref1$[j$];
        if (0 > dirContents.indexOf(mat)) {
          lresult$.push(fs.symlinkSync('../../' + '/by-id/' + mat, path + '/' + key + '/' + mat));
        }
      }
      results$.push(lresult$);
    }
    return results$;
  };
  updateSymlinks = function(){
    var cleanupTitle, yankIds, entries, titleGrouped, dateTrim, dateGrouped, tags, tagGrouped, i$, len$, tag;
    cleanupTitle = function(it){
      return it.split('/').join('_');
    };
    yankIds = function(it){
      return Obj.map(function(it){
        return map(function(it){
          return it.id;
        }, it);
      }, it);
    };
    entries = getAllEntries();
    titleGrouped = yankIds(
    groupBy(function(it){
      return cleanupTitle(it.title);
    }, entries));
    updateSymlinkDir('by-title', titleGrouped);
    dateTrim = function(it){
      if (it.date.toISOString) {
        return it.date.toISOString().split('T')[0];
      } else {
        return it.date.split('T')[0];
      }
    };
    dateGrouped = yankIds(
    groupBy(dateTrim, entries));
    updateSymlinkDir('by-date', dateGrouped);
    tags = unique(
    concat(
    map(function(it){
      return it.tags;
    }, entries)));
    tagGrouped = {};
    for (i$ = 0, len$ = tags.length; i$ < len$; ++i$) {
      tag = tags[i$];
      tagGrouped[tag] = map(fn$)(
      filter(fn1$, entries));
    }
    return updateSymlinkDir('by-tag', tagGrouped);
    function fn$(it){
      return it.id;
    }
    function fn1$(it){
      return -1 < it.tags.indexOf(tag);
    }
  };
  selectMenu = function(files){
    var menu, i$, len$, file;
    files = sortBy(function(it){
      return it.mtime;
    }, files);
    menu = createMenu(800);
    menu.reset();
    menu.write("Select note to edit:\n");
    menu.write("--------------------\n");
    for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
      file = files[i$];
      menu.add([file.title, file.mtime.toISOString(), file.id].join(' | ') + "\n");
    }
    menu.on('select', function(it){
      var ref$;
      menu.close();
      return console.log((ref$ = it.split(' | '))[ref$.length - 1]);
    });
    return menu.createStream().pipe(process.stdout);
  };
  searchTitle = function(){
    var titles, files, search, i$, len$, title, j$, ref$, len1$, ff, file;
    titles = fs.readdirSync(deltosHome + '/by-title');
    files = [];
    search = process.argv.slice(3).join(' ').toLowerCase();
    for (i$ = 0, len$ = titles.length; i$ < len$; ++i$) {
      title = titles[i$];
      if (title.toLowerCase().indexOf(search) < 0) {
        continue;
      }
      for (j$ = 0, len1$ = (ref$ = fs.readdirSync(deltosHome + '/by-title/' + title)).length; j$ < len1$; ++j$) {
        ff = ref$[j$];
        file = {
          title: title,
          id: ff,
          mtime: fs.statSync(deltosHome + '/by-id/' + ff).mtime
        };
        files.push(file);
      }
    }
    return selectMenu(files);
  };
  searchTag = function(){
    var files, tag, i$, ref$, len$, ff, file, ee;
    files = [];
    tag = process.argv.slice(3).join(' ');
    try {
      for (i$ = 0, len$ = (ref$ = fs.readdirSync(deltosHome + '/by-tag/' + tag)).length; i$ < len$; ++i$) {
        ff = ref$[i$];
        file = {
          title: readEntryFromFile(getFilename(ff)).title,
          id: ff,
          mtime: fs.statSync(deltosHome + '/by-id/' + ff).mtime
        };
        files.push(file);
      }
      files = sortBy(function(it){
        return it.mtime;
      }, files);
      return files;
    } catch (e$) {
      ee = e$;
      console.error("No such tag.");
      return process.exit(1);
    }
  };
  searchTagInteractive = function(){
    return selectMenu(searchTag());
  };
  searchTagPipe = function(){
    process.stdout.on('error', function(){
      return process.exit(0);
    });
    return searchTag().map(function(it){
      return console.log(it.id);
    });
  };
  buildPage = function(eep, content){
    var template;
    template = jsdom(
    fs.readFileSync(deltosHome + 'single.html', 'utf-8'));
    eep.push(template.body, content);
    return console.log(template.children[0].outerHTML);
  };
  entryRules = function(){
    var page, linkPusher;
    page = new Section();
    page.rule('h1', 'title');
    page.rule('.date', 'date');
    page.rule('.content', 'body');
    linkPusher = function(el, link){
      return el.href = link;
    };
    page.rule('.article-link', 'link', {
      push: linkPusher
    });
    return page;
  };
  render = function(it){
    var entry;
    entry = readEntryFromFile(getFilename(it));
    entry.link = '/by-id/' + entry.id + '.html';
    return buildPage(entryRules(), entry);
  };
  readStdinAsLinesThen = function(func){
    var buf;
    buf = '';
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(it){
      return buf += it;
    });
    return process.stdin.on('end', function(){
      return func(noEmpty(
      buf.split("\n")));
    });
  };
  renderLog = function(){
    return readStdinAsLinesThen(function(lines){
      var entries, page;
      entries = lines.map(function(it){
        return readEntryFromFile(getFilename(it));
      });
      entries.map(function(it){
        it.link = '/by-id/' + it.id + '.html';
        return it;
      });
      page = new Section();
      page.listRule('#column', 'entries', entryRules());
      return buildPage(page, {
        entries: entries
      });
    });
  };
  entryToMarkdownLink = function(it){
    return "- [" + it.title + "](/by-id/" + it.id + ".html)";
  };
  entryToLink = function(it){
    return "- .(" + it.title + "//" + it.id + ")";
  };
  printResult = function(func){
    return function(){
      return console.log(func.apply(this, arguments));
    };
  };
  asMarkdownLinks = function(){
    return readStdinAsLinesThen(function(lines){
      var entries;
      entries = lines.map(function(it){
        return readEntryFromFile(getFilename(it));
      });
      return entries.map(printResult(entryToMarkdownLink));
    });
  };
  recent = function(it){
    var tag;
    tag = it || process.argv[3] || 'published';
    return map(function(it){
      return printResult(entryToLink)(it);
    })(
    reverse(
    sortBy(function(it){
      return it.date;
    })(
    filter(function(it){
      return tagged(tag, it);
    })(
    getAllEntries()))));
  };
  launchEditor = function(file, after){
    var cp;
    cp = spawn(process.env.EDITOR, [file], {
      customFds: [process.stdin, process.stdout, process.stderr]
    });
    return typeof after === 'function' ? after() : void 8;
  };
  writePost = function(){
    return launchEditor(newNote(), updateSymlinks);
  };
  switch (process.argv[2]) {
  case 'new':
    printNewNoteName();
    break;
  case 'update':
    updateSymlinks();
    break;
  case 'stit':
    searchTitle();
    break;
  case 'search-title':
    searchTitle();
    break;
  case 'stag':
    searchTagPipe();
    break;
  case 'search-tag':
    searchTagPipe();
    break;
  case 'render':
    render(process.argv[3]);
    break;
  case 'render-log':
    renderLog();
    break;
  case 'as-markdown-links':
    asMarkdownLinks();
    break;
  case 'recent':
    recent();
    break;
  case 'post':
    writePost();
    break;
  case 'init':
    init();
    break;
  default:
    console.error("Unknown command, try again.");
    process.exit(1);
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
