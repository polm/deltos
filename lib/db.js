// Generated by LiveScript 1.5.0
(function(){
  var sqlite, deltosHome, ref$, readEntry, getAllEntriesQuick, unlinkSync, dbPath, getDb, getPreparedStatements, createEntry, dbInit, dbUpdate, dbDump, getThreadNext, getThreadPrev, getThreadLatest, out$ = typeof exports != 'undefined' && exports || this;
  sqlite = require('better-sqlite3');
  deltosHome = require('./util').deltosHome;
  ref$ = require('./entries'), readEntry = ref$.readEntry, getAllEntriesQuick = ref$.getAllEntriesQuick;
  unlinkSync = require('fs').unlinkSync;
  dbPath = deltosHome + '/deltos.db';
  getDb = function(){
    var db;
    return db = new sqlite(deltosHome + '/deltos.db');
  };
  getPreparedStatements = function(db){
    var ss;
    ss = {};
    ss.entryInsert = db.prepare("insert into entry (id, date, title, thread)values (@id, @date, @title, @thread)");
    ss.wipeEntry = db.prepare("delete from entry where id = @id");
    ss.tagInsert = db.prepare("insert into entry_tag (entry_id, tag)values (@id, @tag)");
    ss.wipeTags = db.prepare("delete from entry_tag where entry_id = @id");
    return ss;
  };
  createEntry = function(db, ss, entry){
    var i$, ref$, len$, tag, results$ = [];
    entry.thread = entry.thread || null;
    ss.entryInsert.run(entry);
    for (i$ = 0, len$ = (ref$ = entry.tags).length; i$ < len$; ++i$) {
      tag = ref$[i$];
      results$.push(ss.tagInsert.run({
        id: entry.id,
        tag: tag
      }));
    }
    return results$;
  };
  out$.dbInit = dbInit = function(){
    var e, db, ss;
    try {
      fs.unlinkSync(dbPath);
    } catch (e$) {
      e = e$;
      'ok';
    }
    db = getDb();
    db.prepare("create table entry (id varchar(8) primary key,date text,title text,thread text)").run();
    db.prepare("create index date_idx on entry(date)").run();
    db.prepare("create index thread_idx on entry(thread)").run();
    db.prepare("create table entry_tag (entry_id varchar(8),tag text)").run();
    db.prepare("create index entry_id_idx on entry_tag(entry_id)").run();
    db.prepare("create index tag_idx on entry_tag(tag)").run();
    ss = getPreparedStatements(db);
    return getAllEntriesQuick(function(entry){
      return createEntry(db, ss, entry);
    });
  };
  out$.dbUpdate = dbUpdate = function(id){
    var db, entry, row, ss;
    db = getDb();
    entry = readEntry(id);
    row = db.prepare("select * from entry where id = @id").get(entry);
    ss = getPreparedStatements(db);
    ss.wipeEntry.run(entry);
    ss.wipeTags.run(entry);
    return createEntry(db, ss, entry);
  };
  out$.dbDump = dbDump = function(output){
    var db, entries, iterator, entry;
    db = getDb();
    entries = db.prepare("select * from entry order by date desc").iterate();
    while (!(iterator = entries.next()).done) {
      entry = iterator.value;
      console.log(entry);
    }
    return db.close();
  };
  out$.getThreadNext = getThreadNext = function(id){
    var db, entry, nextId;
    db = getDb();
    entry = db.prepare("select * from entry where id = ?").get(id);
    if (!entry || !entry.thread) {
      return id;
    }
    nextId = db.prepare("select id from entry where date > @date and thread = @thread\norder by date asc limit 1").get(entry);
    db.close();
    return (nextId != null ? nextId.id : void 8) || id;
  };
  out$.getThreadPrev = getThreadPrev = function(id){
    var db, entry, nextId;
    db = getDb();
    entry = db.prepare("select * from entry where id = ?").get(id);
    if (!entry || !entry.thread) {
      return id;
    }
    nextId = db.prepare("select id from entry where date < @date and thread = @thread\norder by date desc limit 1").get(entry);
    db.close();
    return (nextId != null ? nextId.id : void 8) || id;
  };
  out$.getThreadLatest = getThreadLatest = function(name){
    var db, entry;
    if (!name) {
      return '';
    }
    db = getDb();
    entry = db.prepare("select * from entry where thread = ? order by date desc limit 1").get(name);
    if (!entry) {
      return '';
    }
    return entry.id;
  };
}).call(this);
