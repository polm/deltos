// Generated by LiveScript 1.5.0
(function(){
  var ref$, memoize, localIsoTime, getYesterday, yaml, yamlDump, deltosHome, BASEDIR, getFilename, tagged, getUrl, getMtime, fs, uuid, map, filter, values, sortBy, reverse, newNote, dumpTodos, renderTsvEntry, grepEntries, philtreEntries, readEntry, revDate, getAllEntries, getAllEntriesQuick, getRawEntry, getEntryParts, getNewId, out$ = typeof exports != 'undefined' && exports || this;
  ref$ = require('./util'), memoize = ref$.memoize, localIsoTime = ref$.localIsoTime, getYesterday = ref$.getYesterday, yaml = ref$.yaml, yamlDump = ref$.yamlDump, deltosHome = ref$.deltosHome, BASEDIR = ref$.BASEDIR, getFilename = ref$.getFilename, tagged = ref$.tagged, getUrl = ref$.getUrl, getMtime = ref$.getMtime;
  fs = require('fs');
  uuid = require('uuid');
  ref$ = require('prelude-ls'), map = ref$.map, filter = ref$.filter, values = ref$.values, sortBy = ref$.sortBy, reverse = ref$.reverse;
  out$.newNote = newNote = function(title, tags, metadata){
    var base, key, fname;
    title == null && (title = "");
    tags == null && (tags = []);
    metadata == null && (metadata = {});
    base = {
      id: getNewId(),
      date: localIsoTime(),
      title: title,
      tags: tags
    };
    for (key in metadata) {
      base[key] = metadata[key];
    }
    fname = getFilename(base.id);
    fs.mkdirSync(fname);
    fs.writeFileSync(fname + '/deltos', yamlDump(base) + '---\n');
    return base.id;
  };
  out$.dumpTodos = dumpTodos = function(){
    var entries, this$ = this;
    entries = sortBy(function(it){
      return it.todo;
    })(
    filter(function(it){
      return it.todo && !it.done;
    })(
    getAllEntries()));
    return entries.map(function(it){
      return "- .(" + it.title + "//" + it.id + ") " + it.todo;
    }).join("\n");
  };
  out$.renderTsvEntry = renderTsvEntry = function(entry){
    return [
      entry.title, entry.tags.map(function(it){
        return '#' + it;
      }).join(','), entry.date.substr(0, 10), entry.id
    ].join('\t');
  };
  out$.grepEntries = grepEntries = function(pat){
    var ignorecase, regex, entries, hits, i$, len$, entry, j$, ref$, len1$, line;
    ignorecase = /[A-Z]/.test(pat) ? '' : 'i';
    regex = new RegExp(pat, ignorecase);
    entries = getAllEntries();
    hits = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      for (j$ = 0, len1$ = (ref$ = entry.rawBody.split("\n")).length; j$ < len1$; ++j$) {
        line = ref$[j$];
        if (regex.test(line)) {
          hits.push(entry.id + ": " + line);
        }
      }
    }
    return hits;
  };
  out$.philtreEntries = philtreEntries = function(query){
    var philtre, out, i$, ref$, len$, hit;
    philtre = require('philtre').philtre;
    out = [];
    for (i$ = 0, len$ = (ref$ = philtre(query, getAllEntries())).length; i$ < len$; ++i$) {
      hit = ref$[i$];
      out.push(hit.id + ": " + hit.title);
    }
    return out;
  };
  out$.readEntry = readEntry = function(id){
    var ref$, metadata, body, e, collection, colls, i$, len$, coll;
    try {
      ref$ = getEntryParts(id), metadata = ref$[0], body = ref$[1];
    } catch (e$) {
      e = e$;
      console.error("Entry ID: " + id);
      console.error("Error parsing YAML header:\n" + metadata);
      console.error("Error message:" + e.message);
      metadata = {
        id: id,
        title: "Error parsing header",
        date: new Date(),
        tags: ['error']
      };
      body = "Could not parse entry.\n\nError message:" + e.message;
      body += "\n\n# Original entry:\n\n" + rawText;
    }
    if (!metadata.title) {
      metadata.title = 'untitled';
    }
    if (!metadata.tags[0]) {
      metadata.tags = ['untagged'];
    }
    if (metadata.location) {
      metadata.location = "Click <a href=\"http://maps.google.com/?q=" + metadata.location + "\">here</a> for a map to this location.";
    }
    if (metadata.parent) {
      if (!metadata.parents) {
        metadata.parents = [];
      }
      metadata.parents.push(metadata.parent);
      delete metadata.parent;
    }
    if (metadata.parents) {
      if (metadata.parents.length === 1) {
        collection = readEntry(metadata.parents[0]);
        if (metadata.lang === 'ja') {
          metadata.collections = "この投稿は<a href=\"" + getUrl(collection) + "\">" + collection.title + "</a>のコレクションに含まれています。";
        } else {
          metadata.collections = "This post is part of a collection on <a href=\"" + getUrl(collection) + "\">" + collection.title + "</a>.";
        }
      } else {
        metadata.collections = "This post is part of collections on ";
        colls = [];
        for (i$ = 0, len$ = (ref$ = metadata.parents).length; i$ < len$; ++i$) {
          coll = ref$[i$];
          collection = readEntry(coll);
          colls.push("<a href=\"" + getUrl(collection) + "\">" + collection.title + "</a>");
        }
        colls[colls.length - 1] = "and " + colls[colls.length - 1] + ".";
        metadata.collections += colls.join(", ");
      }
    }
    metadata.rawBody = body;
    return metadata;
  };
  revDate = function(a, b){
    if (a.date === b.date) {
      return 0;
    }
    if (a.date < b.date) {
      return 1;
    }
    return -1;
  };
  out$.getAllEntries = getAllEntries = memoize(function(){
    var entries, i$, ref$, len$, ff, base, entry, key, parent, this$ = this;
    entries = {};
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      base = BASEDIR + '/' + ff;
      entry = readEntry(ff);
      entries[entry.id] = entry;
    }
    for (key in entries) {
      entry = entries[key];
      if (entry.parent) {
        entry.parents = [entry.parent];
      }
      if (entry.parents) {
        for (i$ = 0, len$ = (ref$ = entry.parents).length; i$ < len$; ++i$) {
          parent = ref$[i$];
          if (!entries[parent].children) {
            entries[parent].children = [];
          }
          entries[parent].children.push(entry.id);
        }
      }
    }
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    values(entries)));
    return entries;
  });
  out$.getAllEntriesQuick = getAllEntriesQuick = function(output){
    var i$, ref$, len$, ff, base, results$ = [];
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      base = BASEDIR + '/' + ff;
      results$.push(output(readEntry(ff)));
    }
    return results$;
  };
  out$.getRawEntry = getRawEntry = function(it){
    var ref$, head, body;
    ref$ = getEntryParts(it), head = ref$[0], body = ref$[1];
    return [yaml(head), body];
  };
  getEntryParts = function(it){
    var raw, parts, header, body, metadata;
    raw = fs.readFileSync(getFilename(it) + '/deltos', 'utf-8');
    parts = raw.split('\n---\n');
    header = parts.shift();
    body = parts.join('\n---\n');
    metadata = yaml(header);
    return [yaml(header), body];
  };
  out$.getNewId = getNewId = function(fnameGetter){
    var id, ref$, fname;
    fnameGetter == null && (fnameGetter = getFilename);
    for (;;) {
      id = uuid.v4();
      id = [(ref$ = id.split('').reverse())[0], ref$[1], ref$[2], ref$[3], ref$[4], ref$[5], ref$[6], ref$[7]].join('');
      fname = fnameGetter(id);
      if (!fs.existsSync(fname)) {
        return id;
      }
    }
  };
}).call(this);
