// Generated by LiveScript 1.4.0
(function(){
  var ref$, memoize, localIsoTime, getYesterday, yaml, yamlDump, deltosHome, BASEDIR, getFilename, tagged, fs, uuid, filter, values, sortBy, reverse, newNote, dumpTodos, renderTsvEntry, dumpTsv, dumpTsvTagged, dumpTsvCore, grepEntries, philtreEntries, readEntry, getAllEntries, getRawEntry, getEntryParts, getNewId, newDaily, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;
  ref$ = require('./util'), memoize = ref$.memoize, localIsoTime = ref$.localIsoTime, getYesterday = ref$.getYesterday, yaml = ref$.yaml, yamlDump = ref$.yamlDump, deltosHome = ref$.deltosHome, BASEDIR = ref$.BASEDIR, getFilename = ref$.getFilename, tagged = ref$.tagged;
  fs = require('fs');
  uuid = require('node-uuid');
  ref$ = require('prelude-ls'), filter = ref$.filter, values = ref$.values, sortBy = ref$.sortBy, reverse = ref$.reverse;
  out$.newNote = newNote = function(title, tags, metadata){
    var base, key, fname;
    title == null && (title = "");
    tags == null && (tags = []);
    metadata == null && (metadata = {});
    base = {
      id: getNewId(),
      date: localIsoTime(),
      title: title,
      tags: tags
    };
    for (key in metadata) {
      base[key] = metadata[key];
    }
    fname = getFilename(base.id);
    fs.writeFileSync(fname, yamlDump(base) + "---\n");
    return fname;
  };
  out$.dumpTodos = dumpTodos = function(){
    var entries;
    entries = sortBy(function(it){
      return it.todo;
    })(
    filter(function(it){
      return it.todo && !it.done;
    })(
    getAllEntries()));
    return entries.map(function(it){
      return "- .(" + it.title + "//" + it.id + ") " + it.todo;
    }).join("\n");
  };
  out$.renderTsvEntry = renderTsvEntry = function(entry){
    return [
      entry.title, entry.tags.map(function(it){
        return '#' + it;
      }).join(','), entry.id
    ].join('\t');
  };
  out$.dumpTsv = dumpTsv = function(){
    return dumpTsvCore(getAllEntries());
  };
  out$.dumpTsvTagged = dumpTsvTagged = function(tag){
    return dumpTsvCore(filter(tagged(tag))(
    getAllEntries()));
  };
  dumpTsvCore = function(entries){
    var out, i$, len$, entry;
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      out.push(renderTsvEntry(entry));
    }
    return out.join("\n");
  };
  out$.grepEntries = grepEntries = function(pat){
    var ignorecase, regex, entries, hits, i$, len$, entry, j$, ref$, len1$, line;
    ignorecase = /[A-Z]/.test(pat) ? '' : 'i';
    regex = new RegExp(pat, ignorecase);
    entries = getAllEntries();
    hits = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      for (j$ = 0, len1$ = (ref$ = entry.rawBody.split("\n")).length; j$ < len1$; ++j$) {
        line = ref$[j$];
        if (regex.test(line)) {
          hits.push(entry.id + ": " + line);
        }
      }
    }
    return hits;
  };
  out$.philtreEntries = philtreEntries = function(query){
    var philtre, out, i$, ref$, len$, hit;
    philtre = require('philtre').philtre;
    out = [];
    for (i$ = 0, len$ = (ref$ = philtre(query, getAllEntries())).length; i$ < len$; ++i$) {
      hit = ref$[i$];
      out.push(hit.id + ": " + hit.title);
    }
    return out;
  };
  readEntry = function(id){
    var rawText, ref$, header, body, metadata, e, collection, colls, i$, len$, coll;
    rawText = fs.readFileSync(getFilename(id), 'utf-8');
    try {
      ref$ = rawText.split("\n---\n"), header = ref$[0], body = ref$[1];
      metadata = yaml(header);
    } catch (e$) {
      e = e$;
      console.error("Error parsing YAML header:\n" + header);
      console.error("Error message:" + e.message);
      metadata = {
        id: id,
        title: "Error parsing header",
        date: new Date(),
        tags: ['error']
      };
      body = "Could not parse entry.\n\nError message:" + e.message;
      body += "\n\n# Original entry:\n\n" + rawText;
    }
    if (!metadata.title) {
      metadata.title = 'untitled';
    }
    if (!metadata.tags[0]) {
      metadata.tags = ['untagged'];
    }
    if (metadata.location) {
      metadata.location = "Click <a href=\"http://maps.google.com/?q=" + metadata.location + "\">here</a> for a map to this location.";
    }
    if (metadata.parent) {
      if (!metadata.parents) {
        metadata.parents = [];
      }
      metadata.parents.push(metadata.parent);
      delete metadata.parent;
    }
    if (metadata.parents) {
      if (metadata.parents.length === 1) {
        collection = readEntry(metadata.parents[0]);
        metadata.collections = "This post is part of a collection on <a href=\"/by-id/" + collection.id + ".html\">" + collection.title + "</a>.";
      } else {
        metadata.collections = "This post is part of collections on ";
        colls = [];
        for (i$ = 0, len$ = (ref$ = metadata.parents).length; i$ < len$; ++i$) {
          coll = ref$[i$];
          collection = readEntry(coll);
          colls.push("<a href=\"/by-id/" + collection.id + ".html\">" + collection.title + "</a>");
        }
        colls[colls.length - 1] = "and " + colls[colls.length - 1] + ".";
        metadata.collections += colls.join(", ");
      }
    }
    metadata.rawBody = body;
    return metadata;
  };
  out$.getAllEntries = getAllEntries = memoize(function(){
    var entries, i$, ref$, len$, ff, entry, key, parent;
    entries = {};
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      entry = readEntry(ff);
      entries[entry.id] = entry;
    }
    for (key in entries) {
      entry = entries[key];
      if (entry.parent) {
        entry.parents = [entry.parent];
      }
      if (entry.parents) {
        for (i$ = 0, len$ = (ref$ = entry.parents).length; i$ < len$; ++i$) {
          parent = ref$[i$];
          if (!entries[parent].children) {
            entries[parent].children = [];
          }
          entries[parent].children.push(entry.id);
        }
      }
    }
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    values(entries)));
  });
  out$.getRawEntry = getRawEntry = function(it){
    var ref$, head, body;
    ref$ = getEntryParts(it), head = ref$[0], body = ref$[1];
    return [yaml(head), body];
  };
  getEntryParts = function(it){
    var text, head, body;
    text = fs.readFileSync(getFilename(it), 'utf-8');
    head = text.split("\n---\n")[0];
    body = slice$.call(text.split("\n---\n"), 1).join("\n---\n");
    return [head, body];
  };
  getNewId = function(){
    var id, ref$, fname;
    for (;;) {
      id = uuid.v4();
      id = [(ref$ = id.split('').reverse())[0], ref$[1], ref$[2], ref$[3], ref$[4], ref$[5], ref$[6], ref$[7]].join('');
      fname = getFilename(id);
      if (!fs.existsSync(fname)) {
        return id;
      }
    }
  };
  out$.newDaily = newDaily = function(){
    var today, entries, existing, ref$, yesterday, ref1$, fname;
    today = localIsoTime().substr(0, 10);
    entries = getAllEntries();
    existing = (ref$ = entries.filter(function(it){
      return it.daily === today;
    })) != null ? ref$[0] : void 8;
    if (existing) {
      return getFilename(existing.id);
    }
    yesterday = (ref1$ = entries.filter(function(it){
      return it.daily === getYesterday();
    })) != null ? ref1$[0] : void 8;
    fname = newNote("Daily Notes - " + today, [], {
      daily: today
    });
    fs.appendFileSync(fname, "\ndeltos todos\n");
    fs.appendFileSync(fname, dumpTodos());
    fs.appendFileSync(fname, "\n\n");
    if (yesterday) {
      fs.appendFileSync(fname, ".(Yesterday//" + yesterday.id + ")\n\n");
    }
    return fname;
  };
}).call(this);
