// Generated by LiveScript 1.4.0
(function(){
  var ref$, memoize, localIsoTime, getYesterday, yaml, yamlDump, deltosHome, BASEDIR, getFilename, tagged, getSlug, getMtime, fs, uuid, filter, values, sortBy, reverse, newNote, dumpTodos, renderTsvEntry, dumpTsv, dumpTsvTagged, dumpTsvCore, grepEntries, philtreEntries, readEntry, loadFullCache, writeFullCache, loadMetaCache, writeMetaCache, loadCache, writeCache, getAllMetadata, getAllEntriesAsync, getAllEntries, getRawEntry, getEntryParts, getNewId, newDaily, out$ = typeof exports != 'undefined' && exports || this;
  ref$ = require('./util'), memoize = ref$.memoize, localIsoTime = ref$.localIsoTime, getYesterday = ref$.getYesterday, yaml = ref$.yaml, yamlDump = ref$.yamlDump, deltosHome = ref$.deltosHome, BASEDIR = ref$.BASEDIR, getFilename = ref$.getFilename, tagged = ref$.tagged, getSlug = ref$.getSlug, getMtime = ref$.getMtime;
  fs = require('fs');
  uuid = require('node-uuid');
  ref$ = require('prelude-ls'), filter = ref$.filter, values = ref$.values, sortBy = ref$.sortBy, reverse = ref$.reverse;
  out$.newNote = newNote = function(title, tags, metadata){
    var base, key, fname;
    title == null && (title = "");
    tags == null && (tags = []);
    metadata == null && (metadata = {});
    base = {
      id: getNewId(),
      date: localIsoTime(),
      title: title,
      tags: tags
    };
    for (key in metadata) {
      base[key] = metadata[key];
    }
    fname = getFilename(base.id);
    fs.mkdirSync(fname);
    fs.writeFileSync(fname + '/meta', yamlDump(base));
    fs.writeFileSync(fname + '/deltos', '...');
    return fname;
  };
  out$.dumpTodos = dumpTodos = function(){
    var entries;
    entries = sortBy(function(it){
      return it.todo;
    })(
    filter(function(it){
      return it.todo && !it.done;
    })(
    getAllEntries()));
    return entries.map(function(it){
      return "- .(" + it.title + "//" + it.id + ") " + it.todo;
    }).join("\n");
  };
  out$.renderTsvEntry = renderTsvEntry = function(entry){
    return [
      entry.title, entry.tags.map(function(it){
        return '#' + it;
      }).join(','), entry.id
    ].join('\t');
  };
  out$.dumpTsv = dumpTsv = function(){
    return dumpTsvCore(getAllMetadata());
  };
  out$.dumpTsvTagged = dumpTsvTagged = function(tag){
    return dumpTsvCore(filter(tagged(tag))(
    getAllMetadata()));
  };
  dumpTsvCore = function(entries){
    var out, i$, len$, entry;
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      out.push(renderTsvEntry(entry));
    }
    return out.join("\n");
  };
  out$.grepEntries = grepEntries = function(pat){
    var ignorecase, regex, entries, hits, i$, len$, entry, j$, ref$, len1$, line;
    ignorecase = /[A-Z]/.test(pat) ? '' : 'i';
    regex = new RegExp(pat, ignorecase);
    entries = getAllEntries();
    hits = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      for (j$ = 0, len1$ = (ref$ = entry.rawBody.split("\n")).length; j$ < len1$; ++j$) {
        line = ref$[j$];
        if (regex.test(line)) {
          hits.push(entry.id + ": " + line);
        }
      }
    }
    return hits;
  };
  out$.philtreEntries = philtreEntries = function(query){
    var philtre, out, i$, ref$, len$, hit;
    philtre = require('philtre').philtre;
    out = [];
    for (i$ = 0, len$ = (ref$ = philtre(query, getAllEntries())).length; i$ < len$; ++i$) {
      hit = ref$[i$];
      out.push(hit.id + ": " + hit.title);
    }
    return out;
  };
  readEntry = function(id, skipBody){
    var header, body, metadata, e, collection, colls, i$, ref$, len$, coll;
    skipBody == null && (skipBody = false);
    try {
      header = fs.readFileSync(getFilename(id) + '/meta', 'utf-8');
      body = '';
      if (!skipBody) {
        body = fs.readFileSync(getFilename(id) + '/deltos', 'utf-8');
      }
      metadata = yaml(header);
    } catch (e$) {
      e = e$;
      console.error("Error parsing YAML header:\n" + header);
      console.error("Error message:" + e.message);
      metadata = {
        id: id,
        title: "Error parsing header",
        date: new Date(),
        tags: ['error']
      };
      body = "Could not parse entry.\n\nError message:" + e.message;
      body += "\n\n# Original entry:\n\n" + rawText;
    }
    if (!metadata.title) {
      metadata.title = 'untitled';
    }
    if (!metadata.tags[0]) {
      metadata.tags = ['untagged'];
    }
    if (metadata.location) {
      metadata.location = "Click <a href=\"http://maps.google.com/?q=" + metadata.location + "\">here</a> for a map to this location.";
    }
    if (metadata.parent) {
      if (!metadata.parents) {
        metadata.parents = [];
      }
      metadata.parents.push(metadata.parent);
      delete metadata.parent;
    }
    if (metadata.parents) {
      if (metadata.parents.length === 1) {
        collection = readEntry(metadata.parents[0]);
        metadata.collections = "This post is part of a collection on <a href=\"/by-id/" + collection.id + ".html#" + getSlug(collection) + "\">" + collection.title + "</a>.";
      } else {
        metadata.collections = "This post is part of collections on ";
        colls = [];
        for (i$ = 0, len$ = (ref$ = metadata.parents).length; i$ < len$; ++i$) {
          coll = ref$[i$];
          collection = readEntry(coll);
          colls.push("<a href=\"/by-id/" + collection.id + ".html#" + getSlug(collection) + "\">" + collection.title + "</a>");
        }
        colls[colls.length - 1] = "and " + colls[colls.length - 1] + ".";
        metadata.collections += colls.join(", ");
      }
    }
    metadata.rawBody = body;
    return metadata;
  };
  loadFullCache = function(){
    return loadCache(deltosHome + '/cache.json');
  };
  writeFullCache = function(it){
    return writeCache(deltosHome + '/cache.json', it);
  };
  loadMetaCache = function(){
    return loadCache(deltosHome + '/cache.meta.json');
  };
  writeMetaCache = function(it){
    return writeCache(deltosHome + '/cache.meta.json', it);
  };
  loadCache = function(cfile){
    if (!fs.existsSync(cfile)) {
      return {
        date: 0,
        entries: {}
      };
    }
    return JSON.parse(fs.readFileSync(cfile, 'utf-8'));
  };
  writeCache = function(cfile, entries){
    var cache;
    cache = {
      date: new Date().toISOString(),
      entries: entries
    };
    return fs.writeFileSync(cfile, JSON.stringify(cache));
  };
  out$.getAllMetadata = getAllMetadata = memoize(function(){
    var cache, entries, cdate, i$, ref$, len$, ff, base, entry;
    cache = loadMetaCache();
    entries = cache.entries;
    cdate = cache.date;
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      base = BASEDIR + '/' + ff;
      if (cdate < getMtime(base + "/meta")) {
        entry = readEntry(ff, true);
        entries[entry.id] = entry;
      }
    }
    writeMetaCache(entries);
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    values(entries)));
  });
  out$.getAllEntriesAsync = getAllEntriesAsync = function(entries, transformer, progress, finish){
    var files, revDate, readFile;
    files = fs.readdirSync(BASEDIR);
    revDate = function(a, b){
      if (a.date === b.date) {
        return 0;
      }
      if (a.date < b.date) {
        return 1;
      }
      return -1;
    };
    readFile = function(){
      var entry;
      if (files.length === 0) {
        entries.sort(revDate);
        if (typeof progress == 'function') {
          progress();
        }
        return typeof finish == 'function' ? finish() : void 8;
      }
      entry = readEntry(files.shift());
      if (transformer) {
        entry = transformer(entry);
      }
      entries.push(entry);
      if (files.length % 100 === 0) {
        entries.sort(revDate);
        if (typeof progress == 'function') {
          progress();
        }
      }
      return setTimeout(readFile, 0);
    };
    readFile();
    return entries;
  };
  out$.getAllEntries = getAllEntries = memoize(function(){
    var cache, entries, cdate, i$, ref$, len$, ff, base, entry, key, parent;
    cache = loadFullCache();
    entries = cache.entries;
    cdate = cache.date;
    for (i$ = 0, len$ = (ref$ = fs.readdirSync(BASEDIR)).length; i$ < len$; ++i$) {
      ff = ref$[i$];
      base = BASEDIR + '/' + ff;
      if (cdate < getMtime(base + "/deltos") || cdate < getMtime(base + "/meta")) {
        entry = readEntry(ff);
        entries[entry.id] = entry;
      }
    }
    for (key in entries) {
      entry = entries[key];
      if (entry.parent) {
        entry.parents = [entry.parent];
      }
      if (entry.parents) {
        for (i$ = 0, len$ = (ref$ = entry.parents).length; i$ < len$; ++i$) {
          parent = ref$[i$];
          if (!entries[parent].children) {
            entries[parent].children = [];
          }
          entries[parent].children.push(entry.id);
        }
      }
    }
    writeFullCache(entries);
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    values(entries)));
  });
  out$.getRawEntry = getRawEntry = function(it){
    var ref$, head, body;
    ref$ = getEntryParts(it), head = ref$[0], body = ref$[1];
    return [yaml(head), body];
  };
  getEntryParts = function(it){
    var head, body;
    head = fs.readFileSync(getFilename(it) + '/meta', 'utf-8');
    body = fs.readFileSync(getFilename(it) + '/deltos', 'utf-8');
    return [head, body];
  };
  out$.getNewId = getNewId = function(fnameGetter){
    var id, ref$, fname;
    fnameGetter == null && (fnameGetter = getFilename);
    for (;;) {
      id = uuid.v4();
      id = [(ref$ = id.split('').reverse())[0], ref$[1], ref$[2], ref$[3], ref$[4], ref$[5], ref$[6], ref$[7]].join('');
      fname = fnameGetter(id);
      if (!fs.existsSync(fname)) {
        return id;
      }
    }
  };
  out$.newDaily = newDaily = function(){
    var today, entries, existing, ref$, yesterday, ref1$, fname;
    today = localIsoTime().substr(0, 10);
    entries = getAllEntries();
    existing = (ref$ = entries.filter(function(it){
      return it.daily === today;
    })) != null ? ref$[0] : void 8;
    if (existing) {
      return getFilename(existing.id);
    }
    yesterday = (ref1$ = entries.filter(function(it){
      return it.daily === getYesterday();
    })) != null ? ref1$[0] : void 8;
    fname = newNote("Daily Notes - " + today, [], {
      daily: today
    });
    fname += '/deltos';
    fs.appendFileSync(fname, "\ndeltos todos\n");
    fs.appendFileSync(fname, dumpTodos());
    fs.appendFileSync(fname, "\n\n");
    if (yesterday) {
      fs.appendFileSync(fname, ".(Yesterday//" + yesterday.id + ")\n\n");
    }
    return fname;
  };
}).call(this);
