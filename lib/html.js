// Generated by LiveScript 1.4.0
(function(){
  var fs, markdown, ref$, memoize, isIn, tagged, yaml, deltosHome, getAllEntries, map, take, sortBy, sortWith, reverse, domino, RSS, eep, Section, render, buildPrivateReference, buildSite, dumpJson, htmlInit, readConfig, buildPage, addMetaTags, setMeta, getRenderedEntries, beginsWith, readEntryBody, getChildEntries, getTemplate, searchableText, entryRules, deltosLinkToHtml, toMarkdownLink, buildListPage, sortOrderThenDate, buildHierarchicalList, getEntriesToBuild, buildSiteHtml, buildRss, out$ = typeof exports != 'undefined' && exports || this;
  fs = require('fs');
  markdown = require('marked');
  ref$ = require('./util'), memoize = ref$.memoize, isIn = ref$.isIn, tagged = ref$.tagged, yaml = ref$.yaml, deltosHome = ref$.deltosHome;
  getAllEntries = require('./entries').getAllEntries;
  ref$ = require('prelude-ls'), map = ref$.map, take = ref$.take, sortBy = ref$.sortBy, sortWith = ref$.sortWith, reverse = ref$.reverse;
  domino = RSS = eep = Section = {};
  out$.render = render = function(it){
    it.link = '/by-id/' + it.id + '.html';
    return buildPage(entryRules(), it);
  };
  out$.buildPrivateReference = buildPrivateReference = function(){
    return buildSite(true);
  };
  out$.buildSite = buildSite = function(priv){
    var config, published, siteRoot, entries;
    priv == null && (priv = false);
    htmlInit();
    config = readConfig();
    published = config.site.tag;
    siteRoot = deltosHome + 'site/';
    if (priv) {
      siteRoot = deltosHome + 'private/';
    }
    entries = getEntriesToBuild(published, priv);
    buildSiteHtml(siteRoot, entries);
    return buildRss(siteRoot, config, entries);
  };
  out$.dumpJson = dumpJson = function(){
    var entries, out, i$, len$, entry;
    htmlInit();
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    getRenderedEntries()));
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.tags = entry.tags.map(String);
      entry.body = searchableText(entry.body);
      out.push(JSON.stringify(entry));
    }
    return out.join("\n");
  };
  htmlInit = function(){
    eep = require('./equaeverpoise');
    Section = eep.Section;
    domino = require('domino');
    return RSS = require('rss');
  };
  readConfig = memoize(function(){
    var e;
    try {
      return yaml(fs.readFileSync(deltosHome + 'config', 'utf-8'));
    } catch (e$) {
      e = e$;
      console.error("Error reading config:\n" + e.message);
      return process.exit(1);
    }
  });
  buildPage = function(eep, content){
    var template;
    if (content.rawBody) {
      content.body = readEntryBody(content);
    }
    template = getTemplate();
    eep.push(template.body, content, template.body);
    if (content.title) {
      template.title = content.title;
    }
    addMetaTags(template, content);
    return template.outerHTML;
  };
  addMetaTags = function(dom, entry){
    var ref$, defaultImage, ref1$, ref2$;
    setMeta(dom, 'og:title', entry.title);
    setMeta(dom, 'og:description', (ref$ = dom.querySelector('p')) != null ? ref$.textContent.split("\n").join(' ') : void 8);
    defaultImage = (ref1$ = dom.querySelector("meta[property=\"og:image\"]")) != null ? (ref2$ = ref1$.attributes['default']) != null ? ref2$.value : void 8 : void 8;
    setMeta(dom, 'og:image', entry.firstImage || defaultImage);
    if (entry.firstImage) {
      return setMeta(dom, 'twitter:card', 'summary_large_image');
    } else {
      return setMeta(dom, 'twitter:card', 'summary');
    }
  };
  setMeta = function(dom, prop, val){
    if (!val) {
      val = '';
    }
    return dom.querySelector("meta[property=\"" + prop + "\"]").setAttribute('content', val);
  };
  getRenderedEntries = function(){
    var entries, i$, len$, entry;
    entries = getAllEntries();
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.body = readEntryBody(entry);
    }
    return entries;
  };
  beginsWith = function(prefix, str){
    return str.substr(0, prefix.length) === prefix;
  };
  readEntryBody = function(it){
    var raw, expanded, i$, ref$, len$, line, words, command, imgSrc, imgTag, caption, vidTag;
    raw = it.rawBody;
    expanded = '';
    if (!raw) {
      return '';
    }
    for (i$ = 0, len$ = (ref$ = raw.split("\n")).length; i$ < len$; ++i$) {
      line = ref$[i$];
      if (beginsWith('!', line)) {
        line = line.slice(1);
        words = line.split(' ');
        command = words.shift();
        switch (command) {
        case 'img':
          imgSrc = words.shift();
          imgTag = "<img src=\"" + imgSrc + "\"/>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + imgTag + caption + "</div>";
          if (!it.firstImage) {
            it.firstImage = imgSrc;
          }
          break;
        case 'video':
          vidTag = "<video preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\" style=\"width: 100%; height: auto;\" controls> <source src=\"" + words.shift() + "\" type='video/webm; codecs=\"vp8, vorbis\"'></source> </video>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + vidTag + caption + "</div>";
          break;
        case 'archive':
          line = buildListPage().join("\n");
          break;
        case 'children':
          line = buildListPage(getChildEntries(it)).join("\n");
          break;
        case 'recent':
          line = buildListPage().slice(0, 5).join("\n");
          break;
        case '.rule':
          line = '<p class="rule">' + markdown(words.join(' ')).substr(3);
          break;
        default:
          'noop';
        }
      }
      expanded += line + "\n";
    }
    expanded = deltosLinkToHtml(expanded);
    return markdown(expanded);
  };
  getChildEntries = function(parent){
    var out;
    out = getAllEntries().filter(function(it){
      return -1 !== parent.children.indexOf(it.id);
    });
    return out;
  };
  getTemplate = memoize(function(){
    return function(it){
      return domino.createWindow(it).document;
    }(
    fs.readFileSync(deltosHome + 'single.html', 'utf-8'));
  });
  searchableText = function(it){
    return domino.createWindow(it).document.body.textContent.toLowerCase();
  };
  entryRules = function(){
    var page, linkPusher;
    page = new Section();
    page.rule('h1', 'title');
    page.rule('h4', 'subtitle');
    page.rule('.location', 'location');
    page.rule('.collections', 'collections');
    page.rule('.date', 'date');
    page.rule('.content', 'body');
    linkPusher = function(el, link){
      return el.href = link;
    };
    page.rule('.article-link', 'link', {
      push: linkPusher
    });
    return page;
  };
  deltosLinkToHtml = function(it){
    var linkRegex;
    linkRegex = /\.\(([^\/]*)\/\/([^\)]*)\)/g;
    return it.replace(linkRegex, function(matched, label, dest){
      return "<a href=\"/by-id/" + dest + ".html\">" + label + "</a>";
    });
  };
  toMarkdownLink = function(it){
    var tags;
    tags = it.tags.filter(function(it){
      return it !== 'published';
    }).join(", ");
    return "- [" + it.title + "](/by-id/" + it.id + ".html) <span class=\"tags\">" + tags + "</span>";
  };
  buildListPage = function(entries){
    var config, i$, ref$, len$, tag;
    if (!entries) {
      entries = getAllEntries();
    }
    config = readConfig();
    for (i$ = 0, len$ = (ref$ = config.site["exclude-tags"]).length; i$ < len$; ++i$) {
      tag = ref$[i$];
      entries = entries.filter(fn$);
    }
    entries = entries.filter(function(it){
      return tagged('published', it);
    });
    return map(toMarkdownLink)(
    reverse(
    sortBy(function(it){
      return it.date;
    }, entries)));
    function fn$(it){
      return !tagged(tag, it);
    }
  };
  sortOrderThenDate = function(a, b){
    if ((a != null && a.order) && (b != null && b.order)) {
      if (a.order < b.order) {
        return 1;
      } else {
        return -1;
      }
    }
    if (a.date > b.date) {
      return -1;
    } else {
      return 1;
    }
  };
  buildHierarchicalList = function(entries, depth, parent){
    var children, out, spacer, i$, len$, child;
    parent == null && (parent = null);
    if (depth === 0) {
      return '';
    }
    if (parent) {
      children = entries.filter(function(it){
        return it.parents && isIn(it.parents, parent);
      });
    } else {
      children = entries.filter(function(it){
        return !it.parents;
      });
    }
    children = sortWith(sortOrderThenDate, children);
    out = '';
    spacer = parent ? '  ' : '';
    for (i$ = 0, len$ = children.length; i$ < len$; ++i$) {
      child = children[i$];
      out += spacer + toMarkdownLink(child) + "\n";
      if (depth > 0) {
        out += buildHierarchicalList(entries, depth - 1, child.id).split("\n").map(fn$).join('\n');
      }
    }
    return out;
    function fn$(it){
      return spacer + it;
    }
  };
  getEntriesToBuild = function(published, priv){
    var entries;
    entries = getRenderedEntries();
    if (!priv) {
      entries = entries.filter(tagged(published));
    }
    return reverse(
    sortBy(function(it){
      return it.date;
    })(
    entries));
  };
  buildSiteHtml = function(root, entries){
    var i$, len$, entry, page, fname, results$ = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      page = render(entry);
      fname = root + "/by-id/" + entry.id + ".html";
      results$.push(fs.writeFileSync(fname, page));
    }
    return results$;
  };
  buildRss = function(root, config, entries){
    var rss, i$, ref$, len$, tag, entry;
    rss = new RSS({
      title: config.site.title,
      description: config.site.description,
      generator: 'deltos',
      site_url: config.site.url,
      feed_url: config.site.url + "/index.rss",
      pubDate: new Date()
    });
    for (i$ = 0, len$ = (ref$ = config.site["exclude-tags"]).length; i$ < len$; ++i$) {
      tag = ref$[i$];
      entries = entries.filter(fn$);
    }
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.description = entry.body;
      entry.categories = entry.tags;
      entry.url = entry.link;
      entry.guid = entry.link;
      rss.item(entry);
    }
    return fs.writeFileSync(root + "index.rss", rss.xml());
    function fn$(it){
      return !tagged(tag, it);
    }
  };
}).call(this);
