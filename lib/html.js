// Generated by LiveScript 1.5.0
(function(){
  var fs, ref$, markdown, getMtime, memoize, isIn, tagged, yaml, yamlDump, deltosHome, readConfig, getFilename, getSlug, getAllEntries, getRawEntry, map, take, sortBy, sortWith, reverse, dirname, renderBlock, domino, RSS, eep, Section, render, buildPrivateReference, buildSite, buildSiteCore, cleanDir, flagUpdated, dumpJson, entriesToJson, htmlInit, buildPageCore, buildPageHtml, buildPageData, addMetaTags, defaultImage, setMeta, getMetaData, getRenderedEntries, beginsWith, RENDERED_CACHE, readEntryBody, getTemplate, searchableText, entryRules, buildSiteHtml, buildRss, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;
  fs = require('fs-extra');
  ref$ = require('./util'), markdown = ref$.markdown, getMtime = ref$.getMtime, memoize = ref$.memoize, isIn = ref$.isIn, tagged = ref$.tagged, yaml = ref$.yaml, yamlDump = ref$.yamlDump, deltosHome = ref$.deltosHome, readConfig = ref$.readConfig, getFilename = ref$.getFilename, getSlug = ref$.getSlug;
  ref$ = require('./entries'), getAllEntries = ref$.getAllEntries, getRawEntry = ref$.getRawEntry;
  ref$ = require('prelude-ls'), map = ref$.map, take = ref$.take, sortBy = ref$.sortBy, sortWith = ref$.sortWith, reverse = ref$.reverse;
  dirname = require('path').dirname;
  renderBlock = require('./blocks').renderBlock;
  domino = RSS = eep = Section = {};
  out$.render = render = function(it){
    it.link = '/by-id/' + it.id + '/' + "#" + getSlug(it);
    return buildPageHtml(entryRules(), it);
  };
  out$.buildPrivateReference = buildPrivateReference = function(){
    var root, entries, after;
    root = deltosHome + 'private/';
    entries = getAllEntries();
    after = function(){
      return fs.writeFileSync(root + 'deltos.json', entriesToJson(entries, root + 'deltos.json'));
    };
    return buildSiteCore(entries, root, entries, after);
  };
  out$.buildSite = buildSite = function(){
    var entries, publicEntries, root, after;
    entries = getAllEntries().filter(tagged('published'));
    publicEntries = entries.filter(function(it){
      return !tagged('hidden', it);
    });
    root = deltosHome + 'site/';
    after = function(){
      return fs.writeFileSync(root + 'deltos.json', entriesToJson(publicEntries, root + 'deltos.json'));
    };
    return buildSiteCore(entries, root, publicEntries, after);
  };
  buildSiteCore = function(entries, siteRoot, publicEntries, after){
    var this$ = this;
    htmlInit();
    cleanDir(siteRoot, entries);
    flagUpdated(siteRoot, entries);
    buildSiteHtml(siteRoot, entries);
    if (publicEntries) {
      publicEntries = reverse(
      sortBy(function(it){
        return it.date;
      })(
      publicEntries));
      buildRss(siteRoot, readConfig(), publicEntries);
    }
    return typeof after == 'function' ? after() : void 8;
  };
  cleanDir = function(root, entries){
    var files, e, i$, len$, file, id, results$ = [];
    try {
      files = fs.readdirSync(root + "/by-id/");
    } catch (e$) {
      e = e$;
      return;
    }
    for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
      file = files[i$];
      id = file.split('.')[0];
      if (entries.filter(fn$).length < 1) {
        results$.push(fs.removeSync(root + "/by-id/" + file));
      }
    }
    return results$;
    function fn$(it){
      return id === it.id;
    }
  };
  flagUpdated = function(root, entries){
    var i$, len$, entry, htmlFname, lresult$, j$, ref$, len1$, child, parent, results$ = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      htmlFname = root + "/by-id/" + entry.id + "/index.html";
      if (getMtime(htmlFname) < getMtime(getFilename(entry.id) + '/deltos')) {
        entry.updated = true;
      }
    }
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      lresult$ = [];
      if (entry.updated) {
        continue;
      }
      if (entry.children) {
        for (j$ = 0, len1$ = (ref$ = entries.filter(fn$)).length; j$ < len1$; ++j$) {
          child = ref$[j$];
          if (child.updated) {
            entry.updated = true;
          }
        }
      }
      if (entry.parents) {
        for (j$ = 0, len1$ = (ref$ = entries.filter(fn1$)).length; j$ < len1$; ++j$) {
          parent = ref$[j$];
          if (parent.updated) {
            lresult$.push(entry.updated = true);
          }
        }
      }
      results$.push(lresult$);
    }
    return results$;
    function fn$(it){
      return isIn(entry.children, it.id);
    }
    function fn1$(it){
      return isIn(entry.parents, it.id);
    }
  };
  out$.dumpJson = dumpJson = function(){
    var entries, this$ = this;
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    getRenderedEntries()));
    return entriesToJson(entries);
  };
  entriesToJson = function(entries, cacheFile){
    var cache, lines, i$, len$, line, entry, e, out, data;
    cache = {};
    if (cacheFile) {
      try {
        lines = fs.readFileSync(cacheFile, 'utf-8').split("\n");
        for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
          line = lines[i$];
          if (line === '') {
            continue;
          }
          entry = JSON.parse(line);
          cache[entry.id] = entry;
        }
      } catch (e$) {
        e = e$;
        'ok';
      }
    }
    htmlInit();
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      if (cacheFile && cache[entry.id] && !entry.updated) {
        data = cache[entry.id];
      } else {
        entry.updated = true;
        data = buildPageData(entryRules(), entry);
      }
      out.push(JSON.stringify(data));
    }
    return out.join("\n");
  };
  htmlInit = function(){
    eep = require('./equaeverpoise');
    Section = eep.Section;
    domino = require('domino');
    return RSS = require('rss');
  };
  buildPageCore = function(eep, content){
    var template;
    if (content.rawBody) {
      content.body = readEntryBody(content);
    }
    if (tagged('hidden', content)) {
      content.date = '';
    }
    template = getTemplate(content.template);
    if (content.updated) {
      eep.push(template.body, content, template.body);
      if (content.title) {
        template.title = content.title;
      }
      addMetaTags(template, content);
    } else {
      template = {
        outerHTML: false
      };
    }
    return {
      dom: template,
      entry: content
    };
  };
  buildPageHtml = function(eep, content){
    return buildPageCore(eep, content).dom.outerHTML;
  };
  buildPageData = function(eep, content){
    return buildPageCore(eep, content).entry;
  };
  addMetaTags = function(dom, entry){
    var parts, fname, ftype, ref$, path, metadata, i$, len$, key, cardType;
    if (entry.firstImage && !entry.metaImage) {
      parts = entry.firstImage.split('/');
      fname = parts[parts.length - 1];
      ftype = (ref$ = fname.split('.'))[ref$.length - 1];
      path = slice$.call(parts, 0, -1).join('/');
      entry.thumbnail = readConfig().url + path + '/' + fname.substr(0, fname.length - 6) + '.s.' + ftype;
      entry.metaImage = readConfig().url + entry.firstImage;
    }
    metadata = getMetaData(dom, entry);
    for (i$ = 0, len$ = (ref$ = ['title', 'description', 'image']).length; i$ < len$; ++i$) {
      key = ref$[i$];
      setMeta(dom, "og:" + key, metadata[key]);
      entry[key] = metadata[key];
    }
    cardType = entry.metaImage ? 'summary_large_image' : 'summary';
    return setMeta(dom, 'twitter:card', cardType);
  };
  defaultImage = function(dom){
    var ref$, ref1$;
    return (ref$ = dom.querySelector("meta[property=\"og:image\"]")) != null ? (ref1$ = ref$.attributes['default']) != null ? ref1$.value : void 8 : void 8;
  };
  setMeta = function(dom, prop, val){
    if (!val) {
      val = '';
    }
    return dom.querySelector("meta[property=\"" + prop + "\"]").setAttribute('content', val);
  };
  getMetaData = function(dom, entry){
    var ref$;
    return {
      title: entry.title,
      description: (ref$ = dom.querySelector('p')) != null ? ref$.textContent.split("\n").join(' ') : void 8,
      image: entry.metaImage || defaultImage(dom)
    };
  };
  getRenderedEntries = function(){
    var entries, i$, len$, entry;
    entries = getAllEntries();
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.body = readEntryBody(entry);
    }
    return entries;
  };
  beginsWith = function(prefix, str){
    return str.substr(0, prefix.length) === prefix;
  };
  RENDERED_CACHE = {};
  readEntryBody = function(entry){
    var entries, i$, ref$, len$, child, childEntry, expanded, block;
    if (RENDERED_CACHE[entry.id]) {
      return RENDERED_CACHE[entry.id];
    }
    if (entry.children) {
      entries = getAllEntries();
      for (i$ = 0, len$ = (ref$ = entry.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        childEntry = entries.filter(fn$)[0];
        readEntryBody(childEntry);
      }
    }
    expanded = '';
    for (i$ = 0, len$ = (ref$ = entry.rawBody.split("\n\n")).length; i$ < len$; ++i$) {
      block = ref$[i$];
      expanded += "\n\n" + renderBlock(block, entry);
    }
    expanded = markdown(expanded);
    RENDERED_CACHE[entry.id] = expanded;
    return expanded;
    function fn$(it){
      return child === it.id;
    }
  };
  getTemplate = memoize(function(template){
    template == null && (template = "single");
    return function(it){
      return domino.createWindow(it).document;
    }(
    fs.readFileSync(deltosHome + ("theme/" + template + ".html"), 'utf-8'));
  });
  searchableText = function(it){
    return domino.createWindow(it).document.body.textContent.toLowerCase();
  };
  entryRules = function(){
    var page, linkPusher;
    page = new Section();
    page.rule('h1', 'title');
    page.rule('h4', 'subtitle');
    page.rule('.location', 'location');
    page.rule('.collections', 'collections');
    page.rule('.date', 'date');
    page.rule('.content', 'body');
    linkPusher = function(el, link){
      return el.href = link;
    };
    page.rule('.article-link', 'link', {
      push: linkPusher
    });
    return page;
  };
  buildSiteHtml = function(root, entries){
    var i$, len$, entry, lresult$, suffix, html, ref$, head, body, orig, j$, len1$, fname, results$ = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      lresult$ = [];
      suffix = "/by-id/" + entry.id;
      html = render(entry);
      if (!html) {
        continue;
      }
      fs.mkdirpSync(root + "" + suffix);
      fs.writeFileSync(root + "" + suffix + "/index.html", html);
      if (entry.slug) {
        fs.removeSync(root + "/" + entry.slug + ".html");
        fs.mkdirpSync(dirname(root + "/" + entry.slug));
        fs.symlinkSync(root + "" + suffix + "/index.html", root + "/" + entry.slug + ".html");
      }
      ref$ = getRawEntry(entry.id), head = ref$[0], body = ref$[1];
      head.source = readConfig().url + "" + suffix + "/index.html";
      orig = getFilename(entry.id);
      for (j$ = 0, len1$ = (ref$ = fs.readdirSync(orig)).length; j$ < len1$; ++j$) {
        fname = ref$[j$];
        fs.removeSync(root + "" + suffix + "/" + fname);
        lresult$.push(fs.symlinkSync(orig + '/' + fname, root + "" + suffix + "/" + fname));
      }
      results$.push(lresult$);
    }
    return results$;
  };
  buildRss = function(root, config, entries){
    var rss, i$, ref$, len$, entry;
    rss = new RSS({
      title: config.title,
      description: config.description,
      generator: 'deltos',
      site_url: config.url,
      feed_url: config.url + "/index.rss",
      pubDate: new Date(),
      author: config.author
    });
    for (i$ = 0, len$ = (ref$ = entries.slice(0, 5)).length; i$ < len$; ++i$) {
      entry = ref$[i$];
      rss.item({
        title: entry.title,
        date: entry.date,
        description: entry.body,
        categories: entry.tags,
        url: entry.link,
        guid: entry.link.split('#')[0]
      });
    }
    return fs.writeFileSync(root + "index.rss", rss.xml());
  };
}).call(this);
