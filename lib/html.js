// Generated by LiveScript 1.4.0
(function(){
  var fs, Markdown, markdown, ref$, memoize, isIn, tagged, yaml, yamlDump, deltosHome, readConfig, getFilename, getAllEntries, getRawEntry, map, take, sortBy, sortWith, reverse, domino, RSS, eep, Section, render, buildPrivateReference, buildSite, buildSiteCore, dumpJson, entriesToJson, htmlInit, buildPageCore, buildPageHtml, buildPageData, addMetaTags, defaultImage, setMeta, getMetaData, getRenderedEntries, beginsWith, readEntryBody, getChildEntries, getTemplate, searchableText, entryRules, deltosLinkToHtml, toMarkdownLink, buildListPage, sortOrderThenDate, buildHierarchicalList, buildSiteHtml, getMtime, buildRss, out$ = typeof exports != 'undefined' && exports || this;
  fs = require('fs');
  Markdown = require('markdown-it')({
    html: true
  });
  markdown = function(it){
    return Markdown.render(it);
  };
  ref$ = require('./util'), memoize = ref$.memoize, isIn = ref$.isIn, tagged = ref$.tagged, yaml = ref$.yaml, yamlDump = ref$.yamlDump, deltosHome = ref$.deltosHome, readConfig = ref$.readConfig, getFilename = ref$.getFilename;
  ref$ = require('./entries'), getAllEntries = ref$.getAllEntries, getRawEntry = ref$.getRawEntry;
  ref$ = require('prelude-ls'), map = ref$.map, take = ref$.take, sortBy = ref$.sortBy, sortWith = ref$.sortWith, reverse = ref$.reverse;
  domino = RSS = eep = Section = {};
  out$.render = render = function(it){
    it.link = '/by-id/' + it.id + '.html';
    return buildPageHtml(entryRules(), it);
  };
  out$.buildPrivateReference = buildPrivateReference = function(){
    var root, entries, after;
    root = deltosHome + 'private/';
    entries = getAllEntries();
    after = function(){
      return fs.writeFileSync(root + 'deltos.json', entriesToJson(entries));
    };
    return buildSiteCore(entries, root, entries, after);
  };
  out$.buildSite = buildSite = function(){
    var entries, publicEntries, root, after;
    entries = getAllEntries().filter(tagged('published'));
    publicEntries = entries.filter(function(it){
      return !tagged('hidden', it);
    });
    root = deltosHome + 'site/';
    after = function(){
      return fs.writeFileSync(root + 'deltos.json', entriesToJson(publicEntries));
    };
    return buildSiteCore(entries, root, publicEntries, after);
  };
  buildSiteCore = function(entries, siteRoot, publicEntries, after){
    htmlInit();
    buildSiteHtml(siteRoot, entries);
    if (publicEntries) {
      publicEntries = reverse(
      sortBy(function(it){
        return it.date;
      })(
      publicEntries));
      buildRss(siteRoot, readConfig(), publicEntries);
    }
    return typeof after == 'function' ? after() : void 8;
  };
  out$.dumpJson = dumpJson = function(){
    var entries;
    entries = reverse(
    sortBy(function(it){
      return it.date;
    })(
    getRenderedEntries()));
    return entriesToJson(entries);
  };
  entriesToJson = function(entries){
    var out, i$, len$, entry, data;
    htmlInit();
    out = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      data = buildPageData(entryRules(), entry);
      out.push(JSON.stringify(data));
    }
    return out.join("\n");
  };
  htmlInit = function(){
    eep = require('./equaeverpoise');
    Section = eep.Section;
    domino = require('domino');
    return RSS = require('rss');
  };
  buildPageCore = function(eep, content){
    var template;
    if (content.rawBody) {
      content.body = readEntryBody(content);
    }
    template = getTemplate();
    eep.push(template.body, content, template.body);
    if (content.title) {
      template.title = content.title;
    }
    addMetaTags(template, content);
    return {
      dom: template,
      entry: content
    };
  };
  buildPageHtml = function(eep, content){
    return buildPageCore(eep, content).dom.outerHTML;
  };
  buildPageData = function(eep, content){
    var ref$, dom, entry;
    ref$ = buildPageCore(eep, content), dom = ref$.dom, entry = ref$.entry;
    entry.searchableText = entry.title + "\n" + dom.querySelector('.content').textContent;
    return entry;
  };
  addMetaTags = function(dom, entry){
    var metadata, i$, ref$, len$, key, cardType;
    metadata = getMetaData(dom, entry);
    for (i$ = 0, len$ = (ref$ = ['title', 'description', 'image']).length; i$ < len$; ++i$) {
      key = ref$[i$];
      setMeta(dom, "og:" + key, metadata[key]);
      entry[key] = metadata[key];
    }
    cardType = entry.firstImage ? 'summary_large_image' : 'summary';
    return setMeta(dom, 'twitter:card', cardType);
  };
  defaultImage = function(dom){
    var ref$, ref1$;
    return (ref$ = dom.querySelector("meta[property=\"og:image\"]")) != null ? (ref1$ = ref$.attributes['default']) != null ? ref1$.value : void 8 : void 8;
  };
  setMeta = function(dom, prop, val){
    if (!val) {
      val = '';
    }
    return dom.querySelector("meta[property=\"" + prop + "\"]").setAttribute('content', val);
  };
  getMetaData = function(dom, entry){
    var ref$;
    return {
      title: entry.title,
      description: (ref$ = dom.querySelector('p')) != null ? ref$.textContent.split("\n").join(' ') : void 8,
      image: entry.firstImage || defaultImage(dom)
    };
  };
  getRenderedEntries = function(){
    var entries, i$, len$, entry;
    entries = getAllEntries();
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      entry.body = readEntryBody(entry);
    }
    return entries;
  };
  beginsWith = function(prefix, str){
    return str.substr(0, prefix.length) === prefix;
  };
  readEntryBody = function(it){
    var raw, expanded, i$, ref$, len$, line, words, command, imgSrc, imgTag, caption, vidTag;
    raw = it.rawBody;
    expanded = '';
    if (!raw) {
      return '';
    }
    for (i$ = 0, len$ = (ref$ = raw.split("\n")).length; i$ < len$; ++i$) {
      line = ref$[i$];
      if (beginsWith('!', line)) {
        line = line.slice(1);
        words = line.split(' ');
        command = words.shift();
        switch (command) {
        case 'img':
          imgSrc = words.shift();
          imgTag = "<img src=\"" + imgSrc + "\"/>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + imgTag + caption + "</div>";
          if (!it.firstImage) {
            it.firstImage = imgSrc;
          }
          break;
        case 'video':
          vidTag = "<video preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\" style=\"width: 100%; height: auto;\" controls> <source src=\"" + words.shift() + "\" type='video/webm; codecs=\"vp8, vorbis\"'></source> </video>";
          caption = words.length ? '<p class="caption">' + words.join(' ') + '</p>' : '';
          line = "<div class=\"img\">" + vidTag + caption + "</div>";
          break;
        case 'search':
          line = '<div class="search"><input class="deltos-search" type="text"></input><div class="deltos-results"></div><script src="/search.js"></script></div>';
          break;
        case 'archive':
          line = buildListPage().join("\n");
          break;
        case 'children':
          line = buildListPage(getChildEntries(it)).join("\n");
          break;
        case 'recent':
          line = buildListPage().slice(0, 5).join("\n");
          break;
        case '.rule':
          line = '<p class="rule">' + markdown(words.join(' ')).substr(3);
          break;
        default:
          'noop';
        }
      }
      expanded += line + "\n";
    }
    expanded = deltosLinkToHtml(expanded);
    return markdown(expanded);
  };
  getChildEntries = function(parent){
    var out;
    out = getAllEntries().filter(function(it){
      return -1 !== parent.children.indexOf(it.id);
    });
    return out;
  };
  getTemplate = memoize(function(){
    return function(it){
      return domino.createWindow(it).document;
    }(
    fs.readFileSync(deltosHome + 'single.html', 'utf-8'));
  });
  searchableText = function(it){
    return domino.createWindow(it).document.body.textContent.toLowerCase();
  };
  entryRules = function(){
    var page, linkPusher;
    page = new Section();
    page.rule('h1', 'title');
    page.rule('h4', 'subtitle');
    page.rule('.location', 'location');
    page.rule('.collections', 'collections');
    page.rule('.date', 'date');
    page.rule('.content', 'body');
    linkPusher = function(el, link){
      return el.href = link;
    };
    page.rule('.article-link', 'link', {
      push: linkPusher
    });
    return page;
  };
  deltosLinkToHtml = function(it){
    var linkRegex;
    linkRegex = /\.\(([^\/]*)\/\/([^\)]*)\)/g;
    return it.replace(linkRegex, function(matched, label, dest){
      return "<a href=\"/by-id/" + dest + ".html\">" + label + "</a>";
    });
  };
  toMarkdownLink = function(it){
    var tags;
    tags = it.tags.filter(function(it){
      return it !== 'published';
    }).join(", ");
    return "- [" + it.title + "](/by-id/" + it.id + ".html) <span class=\"tags\">" + tags + "</span>";
  };
  buildListPage = function(entries){
    if (!entries) {
      entries = getAllEntries();
    }
    entries = entries.filter(tagged('published')).filter(function(it){
      return !tagged('hidden', it);
    });
    return map(toMarkdownLink)(
    reverse(
    sortBy(function(it){
      return it.date;
    }, entries)));
  };
  sortOrderThenDate = function(a, b){
    if ((a != null && a.order) && (b != null && b.order)) {
      if (a.order < b.order) {
        return 1;
      } else {
        return -1;
      }
    }
    if (a.date > b.date) {
      return -1;
    } else {
      return 1;
    }
  };
  buildHierarchicalList = function(entries, depth, parent){
    var children, out, spacer, i$, len$, child;
    parent == null && (parent = null);
    if (depth === 0) {
      return '';
    }
    if (parent) {
      children = entries.filter(function(it){
        return it.parents && isIn(it.parents, parent);
      });
    } else {
      children = entries.filter(function(it){
        return !it.parents;
      });
    }
    children = sortWith(sortOrderThenDate, children);
    out = '';
    spacer = parent ? '  ' : '';
    for (i$ = 0, len$ = children.length; i$ < len$; ++i$) {
      child = children[i$];
      out += spacer + toMarkdownLink(child) + "\n";
      if (depth > 0) {
        out += buildHierarchicalList(entries, depth - 1, child.id).split("\n").map(fn$).join('\n');
      }
    }
    return out;
    function fn$(it){
      return spacer + it;
    }
  };
  buildSiteHtml = function(root, entries){
    var i$, len$, entry, suffix, htmlFname, ref$, head, body, deltosFname, output, results$ = [];
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      suffix = "/by-id/" + entry.id;
      htmlFname = root + "" + suffix + ".html";
      fs.writeFileSync(htmlFname, render(entry));
      ref$ = getRawEntry(entry.id), head = ref$[0], body = ref$[1];
      head.source = readConfig().url + "" + suffix + ".html";
      deltosFname = root + "" + suffix + ".deltos";
      output = yamlDump(head) + "---\n" + body;
      results$.push(fs.writeFileSync(deltosFname, output));
    }
    return results$;
  };
  getMtime = function(fname){
    var e;
    try {
      return fs.statSync(fname).mtime;
    } catch (e$) {
      e = e$;
      return 0;
    }
  };
  buildRss = function(root, config, entries){
    var rss, i$, len$, entry;
    rss = new RSS({
      title: config.title,
      description: config.description,
      generator: 'deltos',
      site_url: config.url,
      feed_url: config.url + "/index.rss",
      pubDate: new Date()
    });
    for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
      entry = entries[i$];
      rss.item({
        title: entry.title,
        date: entry.date,
        description: entry.body,
        categories: entry.tags,
        url: entry.link,
        guid: entry.link
      });
    }
    return fs.writeFileSync(root + "index.rss", rss.xml());
  };
}).call(this);
